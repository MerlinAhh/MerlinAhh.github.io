{"meta":{"title":"Merlinの博客","subtitle":"前端开发工程师","description":"描述","author":"Merlin","url":"https://merlinahh.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2025-02-05T03:41:20.740Z","updated":"2022-02-15T09:02:48.065Z","comments":false,"path":"/404.html","permalink":"https://merlinahh.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2025-02-05T03:41:20.745Z","updated":"2022-02-14T00:42:03.663Z","comments":false,"path":"categories/index.html","permalink":"https://merlinahh.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2025-02-05T03:41:20.712Z","updated":"2022-02-14T03:14:08.156Z","comments":true,"path":"links/index.html","permalink":"https://merlinahh.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2025-02-05T03:41:20.709Z","updated":"2022-02-14T01:00:55.448Z","comments":false,"path":"tags/index.html","permalink":"https://merlinahh.github.io/tags/index.html","excerpt":"","text":""},{"title":"图库","date":"2025-02-05T03:41:20.705Z","updated":"2022-02-15T07:40:33.748Z","comments":true,"path":"gallery/index.html","permalink":"https://merlinahh.github.io/gallery/index.html","excerpt":"","text":""}],"posts":[{"title":"Mac 安装配置前端开发环境","slug":"Mac-install-develop","date":"2025-02-05T02:42:00.000Z","updated":"2025-02-05T09:22:42.118Z","comments":true,"path":"2025/02/05/Mac-install-develop/","link":"","permalink":"https://merlinahh.github.io/2025/02/05/Mac-install-develop/","excerpt":"","text":"AppStore中下载xcode, 安装适合系统版本的 Xcode Xcode 安装完成后, 打开终端执行以下命令 1xcode-select --install 会唤起 Xcode 来安装命令行工 Command Line Tools 下载 Homebrew 去Homebrew官网 https://brew.sh/ 官网推荐使用 .pkg 安装器安装, 根据建议下载适合的包 按照提示安装好即可 使用 Homebrew 安装 nvm打开终端执行以下命令 1brew install nvm 执行完成不报错即为已安装成功 配置 nvm shell 文件终端打开 ~/.zshrc 文件1open ~/.zshrc 如果不存在先创建该文件再打开 12touch ~/.zshrcopen ~/.zshrc 配置 nvm 环境变量文件不为空时, 在最末行追加 1234567891011121314151617181920212223242526272829303132333435# 配置 nvm 环境export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$(brew --prefix nvm)/nvm.sh&quot; ] &amp;&amp; \\. &quot;$(brew --prefix nvm)/nvm.sh&quot;# 配置 nvm下载镜像源export NVM_NODEJS_ORG_MIRROR=https://nodejs.org/distexport NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node/# 定义自动加载 .nvmrc 的逻辑load-nvmrc() &#123;if [[ -f .nvmrc ]]; then local VERSION VERSION=$(cat .nvmrc) # 获取 .nvmrc 文件中的版本号 # 检查当前版本是否与 .nvmrc 中指定的版本相同 if [[ &quot;$(nvm current)&quot; != &quot;$VERSION&quot; ]]; then # 切换 Node 版本 nvm use &quot;$VERSION&quot; &amp;&gt;/dev/null # 避免不必要的输出 if [[ $? -eq 0 ]]; then echo &quot;Switched to Node version $(node -v)&quot; # 显示当前版本 else echo &quot;Error: Failed to switch Node version&quot; fi else echo &quot;Already using Node version $(node -v)&quot; # 当前版本已经是指定版本 fifi&#125;# 使用 chpwd 钩子，确保每次切换目录时执行 load-nvmrcautoload -U add-zsh-hookadd-zsh-hook chpwd load-nvmrc# 在终端启动时执行一次 load-nvmrc，确保初始加载时正确load-nvmrc 重新加载 .zshrc1source ~/.zshrc 查看 nvm 版本号1nvm -v 返回版本号即配置成功 使用 nvm 安装 nodenvm 管理 node 至此开发基本准备工作已完成 使用 Hexo 搭建博客Hexo 搭建博客 搭建 Vue3 + Vite 项目Vue3 + Vite 项目搭建","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://merlinahh.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Node.js","slug":"Node-js","permalink":"https://merlinahh.github.io/tags/Node-js/"},{"name":"VUE","slug":"VUE","permalink":"https://merlinahh.github.io/tags/VUE/"},{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"author":"Merlin"},{"title":"Vue3 + Vite 项目搭建","slug":"vue3vite","date":"2024-03-11T05:27:42.000Z","updated":"2025-02-05T09:06:44.169Z","comments":true,"path":"2024/03/11/vue3vite/","link":"","permalink":"https://merlinahh.github.io/2024/03/11/vue3vite/","excerpt":"","text":"一、Node 及 npm 版本node 版本需要在 ^18.0.0 || &gt;=20.0.0 区间 nvm 管理 node 查看当前版本 12node -vnpm -v 切换到 20.3.0 1nvm use 20.3.0 二、创建项目使用脚手架创建项目这个命令会安装和执行 create-vue，它是 Vue 提供的官方脚手架工具。 1yarn create vue@latest 跟随命令行的提示继续操作，按需求确认是否使用依赖 执行成功后，进入项目目录 1cd vue3vite/ 得到以下目录结构 安装依赖1yarn 使用 vue-router 进行路由管理1yarn add vue-router 成功后在项目 src 目录下新建 router/index.js 文件, 实现基本功能 123456789101112131415161718192021222324252627282930313233import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;import Login from &quot;@/views/Login.vue&quot;;import NotFind404 from &quot;@/views/error/404.vue&quot;;/** * 白名单，不需要权限也可以访问 */export const constantRoutes = [ &#123; path: &quot;/login&quot;, name: &quot;Login&quot;, component: Login, meta: &#123; roleId: 0, title: &quot;登录&quot; &#125;, &#125;, &#123; path: &quot;/404&quot;, name: &quot;404&quot;, component: NotFind404, meta: &#123; roleId: 0, title: &quot;404页面不存在&quot; &#125;, &#125;, ...];const router = createRouter(&#123; history: createWebHistory(import.meta.env.BASE_URL), routes: constantRoutes, // 是否严格匹配路由 strict: true, // 路由跳转完成后，页面滚动行为 scrollBehavior: () =&gt; (&#123; left: 0, top: 0 &#125;),&#125;);export default router; 使用 vuex 进行状态管理1yarn add vuex --dev 成功后在项目 src 目录下新建 store/index.js 文件 12345678910111213import &#123; createStore &#125; from &quot;vuex&quot;;import CONFIG from &quot;./module/config&quot;;export default createStore(&#123; state: &#123;&#125;, getters: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;, modules: &#123; CONFIG &#125;,&#125;); 使用 axios 统一管理和处理请求1yarn add axios 请求封装创建 request.js 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import axios from &quot;axios&quot;;import router from &quot;@/router&quot;;import &#123; filterUndefined &#125; from &quot;./util&quot;;import &#123; arrayBufferToJson &#125; from &quot;./download&quot;;// 开启 mock 时，访问本地const baseURL = process.env.Mock ? &quot;&quot; : process.env.API_BASE_URL;const instance = axios.create(&#123; baseURL, timeout: 6000,&#125;);instance.__proto__ = axios;instance.interceptors.request.use((config) =&gt; &#123; const &#123; params, data &#125; = config; config.params = params &amp;&amp; filterUndefined(config.params); config.data = data &amp;&amp; filterUndefined(config.data); // 填充 token 到 header 头中 if (localStorage.getItem(&quot;token&quot;)) config.headers.Authorization = localStorage.getItem(&quot;token&quot;); return config;&#125;);instance.interceptors.response.use( (response) =&gt; &#123; let data = response.data; if (process.env.NODE_ENV === &quot;mock&quot;) response.headers[&quot;content-type&quot;] = &quot;application/json; charset=utf-8&quot;; if (response.headers[&quot;content-type&quot;].indexOf(&quot;application/json&quot;) === -1) &#123; // 下载文件请求，状态码为200时，直接返回成功 return Promise.resolve(data); &#125; else &#123; switch (data.code) &#123; // 请求成功 case 9100: return Promise.resolve(data); default: // 请求参数错误 if (data.code === 9200) &#123; // 参数错误为联调时期的问题, 不对用户弹窗提示 &#125; // 9250 用户操作出错 9500 系统繁忙 失败提示弹窗 if (data.code === 9250 || data.code === 9500) &#123; // 弹窗提示错误msg &#125; // 9300 未登录 9400 登录过期 退到登录 弹提示 if (data.code === 9300 || data.code === 9400) &#123; // 弹窗提示msg router.push(&#123; name: &quot;Login&quot; &#125;); // 跳转到登录页面 &#125; // 数据不存在或者已删除 if (data.code === 9404) &#123; // 弹窗提示msg router.replace(&#123; name: &quot;404&quot; &#125;); &#125; return Promise.reject(&#123; ...data, msg: data.msg &#125;); &#125; &#125; &#125;, (error) =&gt; &#123; const response = error.response; let data = null; try &#123; const err = response.data.result &amp;&amp; response.data.result.error; // 登录过期/非法、超时 if (err === &quot;timeout&quot; || err === &quot;invalid&quot;) &#123; // 可以弹窗后执行 console.log(err); &#125; // 将请求类型为ArrayBuffer的二进制数据转换成json data = arrayBufferToJson(response.data).data; &#125; finally &#123; // let msg = data &amp;&amp; data.msg; // 弹窗 msg 信息 &#125; // 开发模式才在控制台打印 if ( process.env.NODE_ENV == &quot;development&quot; || process.env.NODE_ENV === &quot;mock&quot; ) &#123; console.warn(error); &#125; return Promise.reject(response.data); &#125;);/** * 执行并发请求 * @param &#123;Array&#125; request 请求方法 * @param &#123;Array&#125; cbs 请求完成后的回调方法 * @return &#123;Promise&#125; */function all(request, cbs) &#123; return new Promise((resolve, reject) =&gt; &#123; instance .all(request) .then( instance.spread(function () &#123; let arg = [...arguments]; if (Array.isArray(cbs)) &#123; cbs.forEach((fn, index) =&gt; fn(arg[index])); &#125; resolve(arg); &#125;) ) .catch((err) =&gt; &#123; reject(err); &#125;); &#125;);&#125;const get = (url, params, config = &#123;&#125;) =&gt; instance.get(url, &#123; ...config, params &#125;);const deletes = (url, params, config = &#123;&#125;) =&gt; instance.delete(url, &#123; ...config, params &#125;);const post = (url, params, config = &#123;&#125;) =&gt; instance.post(url, params, config);const put = (url, params, config = &#123;&#125;) =&gt; instance.put(url, params, config);export default &#123; get, deletes, post, put, all,&#125;; 使用 docsify 编写项目文档 全局安装 docsify 1yarn global add docsify 项目内安装脚手架 1yarn add docsify-cil 创建文档目录 1docsify init ./docs 运行文档 1docsify serve docs 可以写到 package.json 中 123scripts: &#123; &quot;doc&quot;: &quot;docsify serve docs&quot;,&#125; 具体使用见docsify 文档","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://merlinahh.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Node.js","slug":"Node-js","permalink":"https://merlinahh.github.io/tags/Node-js/"},{"name":"VUE","slug":"VUE","permalink":"https://merlinahh.github.io/tags/VUE/"},{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"author":"Merlin"},{"title":"使用 nvm 来管理 node版本","slug":"nvm-node","date":"2022-02-28T00:09:31.000Z","updated":"2024-02-28T00:33:56.705Z","comments":true,"path":"2022/02/28/nvm-node/","link":"","permalink":"https://merlinahh.github.io/2022/02/28/nvm-node/","excerpt":"","text":"有很多项目、依赖需要指定版本 node 支持才能使用(踩过的坑)，避面切换项目需要频繁安装不通版本 node 这里可以安装 nvm 来进行管理 1.列出已经安装的 node 版本 1nvm ls 2.列出所有可以安装的 node 版本号 1nvm ls-remote 3.安装 node 12345// 安装指定版本的nodenvm install v10.4.0// 安装最新稳定版nodenvm install stable 4.切换已有的 node 版本 1nvm use v10.4.0 5.查看当前node版本 1nvm current 6.指定默认的node版本 nvm alias default v10.4.0 以上是 nvm 的常用命令","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"https://merlinahh.github.io/tags/node/"}],"author":"Merlin"},{"title":"时间戳转具体日时分秒","slug":"trsndformTime","date":"2022-02-17T07:26:01.000Z","updated":"2024-02-28T00:37:23.961Z","comments":true,"path":"2022/02/17/trsndformTime/","link":"","permalink":"https://merlinahh.github.io/2022/02/17/trsndformTime/","excerpt":"","text":"用于需要查询具体时间段的函数，传入时间戳 返回具体时分秒 12345678910111213141516171819202122232425function transformTime(timestamp) &#123; const DAY_MILLISECOND = 86400000; const HOUR_MILLISECOND = 3600000; const MINUTE_MILLISECOND = 60000; const dayValue = (timestamp / DAY_MILLISECOND) | 0; const hourValue = ((timestamp % DAY_MILLISECOND) / HOUR_MILLISECOND) | 0; const minValue = (((timestamp % DAY_MILLISECOND) % HOUR_MILLISECOND) / MINUTE_MILLISECOND) | 0; const secondValue = ((((timestamp % DAY_MILLISECOND) % HOUR_MILLISECOND) % MINUTE_MILLISECOND) / 1000) | 0; const day = dayValue ? dayValue.toString().padStart(2, &quot;0&quot;) + &quot;天&quot; : &quot;&quot;; const hour = day || hourValue ? hourValue.toString().padStart(2, &quot;0&quot;) + &quot;时&quot; : &quot;&quot;; const minute = hour || minValue ? minValue.toString().padStart(2, &quot;0&quot;) + &quot;分&quot; : &quot;&quot;; const second = minute || secondValue ? secondValue.toString().padStart(2, &quot;0&quot;) + &quot;秒&quot; : &quot;&quot;; return day + hour + minute + second;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://merlinahh.github.io/tags/js/"},{"name":"笔记","slug":"笔记","permalink":"https://merlinahh.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Merlin"},{"title":"很好用的 scp 上传文件脚本","slug":"scp-upload-files","date":"2020-07-21T05:11:49.000Z","updated":"2024-06-28T08:33:59.498Z","comments":true,"path":"2020/07/21/scp-upload-files/","link":"","permalink":"https://merlinahh.github.io/2020/07/21/scp-upload-files/","excerpt":"","text":"scp 本地连接远程服务器传输文件，无需二次填写密码确认 文件名后缀为.sh日常更新文件可以命名update.sh 1234567891011# 无需验证直接上传到服务器set user userName #（特殊符号需要转义符^）set pass passWard #（特殊符号需要转义符^）set dir /srv/blog #（服务器目录）set ip $&#123;ipAddr&#125; #（服务器IP）set filen ./public/* #（本地文件目录）spawn scp $&#123;filen&#125; $&#123;user&#125;@$&#123;ip&#125;:$&#123;dir&#125;expect &quot;$&#123;user&#125;@$&#123;ip&#125;&#x27;s password:&quot;send &quot;$&#123;pass&#125;\\r&quot;interact","categories":[{"name":"服务器","slug":"服务器","permalink":"https://merlinahh.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://merlinahh.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Linux","slug":"Linux","permalink":"https://merlinahh.github.io/tags/Linux/"},{"name":"shell脚本","slug":"shell脚本","permalink":"https://merlinahh.github.io/tags/shell%E8%84%9A%E6%9C%AC/"}],"author":"Merlin"},{"title":"MongoDB 用法","slug":"MongoDB-study","date":"2019-11-11T02:36:54.000Z","updated":"2024-02-28T00:44:05.882Z","comments":true,"path":"2019/11/11/MongoDB-study/","link":"","permalink":"https://merlinahh.github.io/2019/11/11/MongoDB-study/","excerpt":"","text":"安装Windows：https://www.runoob.com/mongodb/mongodb-window-install.html Mac：https://www.runoob.com/mongodb/mongodb-osx-install.html Linux：https://www.runoob.com/mongodb/mongodb-linux-install.html SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接,MongoDB不支持 primary key primary key 主键,MongoDB自动将_id字段设置为主键 运行MongoDB我们可以使用 brew 命令或 mongod 命令来启动服务。 brew 启动： 1brew services start mongodb-community@4.4 brew 停止： 1brew services stop mongodb-community@4.4 mongod 命令后台进程方式： 1mongod --config /usr/local/etc/mongod.conf --fork 这种方式启动要关闭可以进入 mongo shell 控制台来实现： 1&gt; db.adminCommand(&#123; &quot;shutdown&quot; : 1 &#125;) 进入MongoDB安装目录下的bin目录，运行mongo程序 mongod 命令启动mongodb mongo 命令连接 执行 show dbs 命令查看所有数据 执行 db 命令可以显示当前数据库对象或集合 use命令可以连接到指定数据库 创建集合 1&gt; db.createCollection(name, options) 参数说明： name: 要创建的集合名称 options: 可选参数, 指定有关内存大小及索引的选项 options 可以是如下参数： 字段 类型 描述 capped 布尔 （可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。当该值为 true 时，必须指定 size 参数。 autoIndexId 布尔 3.2 之后不再支持该参数。（可选）如为 true，自动在 _id 字段创建索引。默认为 false。 size 数值 （可选）为固定集合指定一个最大值，即字节数。如果 capped 为 true，也需要指定该字段。 max 数值 （可选）指定固定集合中包含文档的最大数量。 创建集合并插入数据 1&gt; db.集合名.insert(&#123;...&#125;) 删除数据库下所有集合 1&gt; db.dropDatabase() 删除指定集合 1&gt; db.集合名.drop() 插入数据 12&gt; db.集合名.insert(document) 新增&gt; db.集合名.save(document) 新增或修改，通过主键_id区分 添加单条： 123&gt; db.集合名.insertOne(document,&#123; writeConcern: document&#125;) 添加多条： 12345&gt; db.集合名.insertMany([document1, document2]&#123; writeConcern: document, ordered: boolean&#125;) 参数说明： **document:**要写入的文档。**writeConcern:**写入策略，默认为 1，即要求确认写操作，0 是不要求。**ordered:**指定是否按顺序写入，默认 true，按顺序写入。 更新数据（执行错误） 12345&gt; db.集合名.update(&lt;query&gt;,&lt;update&gt;,&#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt;&#125;) 参数说明： **query:**update的查询条件，类似sql update查询内where后面的。 update: update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的 **upsert:**可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 **multi:**可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 **writeConcern:**可选，抛出异常的级别。 删除数据（执行错误） 12345678&gt; db.集合名.remove(&lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;)&gt; db.集合名.remove(&#123;&#125;) 删除所有数据 参数说明： **query:**（可选）删除的文档的条件。 **justOne:**（可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。 **writeConcern:**（可选）抛出异常的级别。 查询数据 1234&gt; db.集合名.find(query, projection)&gt; db.集合名.find() 查询所有&gt; db.集合名.findOne() 查询单条&gt; db.集合名.find().pretty() 查询数据美化显示 参数说明： query：可选，使用查询操作符指定查询条件 projection：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。 query参数说明： 操作 格式 范例 等于 {:} db.col.find({“name”:”张三三”}).pretty() 小于 {:{$lt:}} db.col.find({“likes”:{$lt:50}}).pretty() 小于或等于 {:{$lte:}} db.col.find({“likes”:{$lte:50}}).pretty() 大于 {:{$gt:}} db.col.find({“likes”:{$gt:50}}).pretty() 大于或等于 {:{$gte:}} db.col.find({“likes”:{$gte:50}}).pretty() 不等于 {:{$ne:}} db.col.find({“likes”:{$ne:50}}).pretty() 多条件AND在query中用逗号分割： 12345678&gt; db.col.find(&#123;key1:value1, key2:value2&#125;).pretty()&gt; db.集合名.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty() $type 通过字段类型查询： 类型 数字 备注 Double 1 String 2 Object 3 Array 4 Binary data 5 Undefined 6 已废弃。 Object id 7 Boolean 8 Date 9 Null 10 Regular Expression 11 JavaScript 13 Symbol 14 JavaScript (with scope) 15 32-bit integer 16 Timestamp 17 64-bit integer 18 Min key 255 Query with -1. Max key 127 查询name类型为string的数据 12&gt; db.集合名.find(&#123;&quot;name&quot;: &#123;$type: &#x27;string&#x27;&#125;&#125;)&gt; db.集合名.find(&#123;&quot;name&quot;: &#123;$type: 2&#125;&#125;) limit()方法固定条数查询： 1&gt; db.集合名.find().limit(NUMBER) skip()方法跳过指定数量查询： skip()参数默认0 1&gt; db.集合名.find().limit(NUMBER).skip(NUMBER) sort()方法 KEY：字段名 sort()参数-1降序1升序 1&gt; db.集合名.find().sort(&#123;KEY:1&#125;) 索引 Key为索引字段，1升序-1降序 1&gt; db.集合名.createIndex(keys, options) options参数说明： Parameter Type Description background Boolean 建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为false。 unique Boolean 建立的索引是否唯一。指定为true创建唯一索引。默认值为false. name string 索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。 dropDups Boolean 3.0+版本已废弃。在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 false. sparse Boolean 对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false. expireAfterSeconds integer 指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。 v index version 索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。 weights document 索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。 default_language string 对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语 language_override string 对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language. MongoDB 聚合https://www.runoob.com/mongodb/mongodb-aggregate.html 数据类型 数据类型 描述 String 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。 Integer 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。 Boolean 布尔值。用于存储布尔值（真/假）。 Double 双精度浮点值。用于存储浮点值。 Min/Max keys 将一个值与 BSdrrON（二进制的 JSON）元素的最低值和最高值相对比。 Array 用于将数组或列表或多个值存储为一个键。 Timestamp 时间戳。记录文档修改或添加的具体时间。 Object 用于内嵌文档。 Null 用于创建空值。 Symbol 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。 Date 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。 Object ID 对象 ID。用于创建文档的 ID。 Binary Data 二进制数据。用于存储二进制数据。 Code 代码类型。用于在文档中存储 JavaScript 代码。 Regular expression 正则表达式类型。用于存储正则表达式。 连接数据库命令行连接1&gt; mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]] **mongodb://**这是固定的格式，必须要指定。 username:password@ 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登录这个数据库 host1 必须的指定至少一个host, host1 是这个URI唯一要填写的。它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。 portX可选的指定端口，如果不填，默认为27017 /database 如果指定username:password@，连接并验证登录指定数据库。若不指定，默认打开 test 数据库。 ?options 是连接选项。如果不使用/database，则前面需要加上/。所有连接选项都是键值对name=value，键值对之间通过&amp;或;（分号）隔开 选项 描述 replicaSet=name 验证replica set的名称。 Impliesconnect=replicaSet. slaveOk=true|false true:在connect=direct模式下，驱动会连接第一台机器，即使这台服务器不是主。在connect=replicaSet模式下，驱动会发送所有的写请求到主并且把读取操作分布在其他从服务器。false: 在 connect=direct模式下，驱动会自动找寻主服务器. 在connect=replicaSet 模式下，驱动仅仅连接主服务器，并且所有的读写命令都连接到主服务器。 safe=true|false true: 在执行更新操作之后，驱动都会发送getLastError命令来确保更新成功。(还要参考 wtimeoutMS).false: 在每次更新之后，驱动不会发送getLastError来确保更新成功。 w=n 驱动添加 { w : n } 到getLastError命令. 应用于safe=true。 wtimeoutMS=ms 驱动添加 { wtimeout : ms } 到 getlasterror 命令. 应用于 safe=true. fsync=true|false true: 驱动添加 { fsync : true } 到 getlasterror 命令.应用于 safe=true.false: 驱动不会添加到getLastError命令中。 journal=true|false 如果设置为 true, 同步到 journal (在提交到数据库前写入到实体中). 应用于 safe=true connectTimeoutMS=ms 可以打开连接的时间。 socketTimeoutMS=ms 发送和接受sockets的时间。 使用用户名密码连接到服务器 1&gt; mongodb://username:password@hostname/dbname Navicat连接 执行mongo后会返回一条连接路径 Navicat创建新连接选择MongoDB使用uri连接，输入上面返回的连接路径 测试成功后点保存，即可连接数据库","categories":[{"name":"数据库","slug":"数据库","permalink":"https://merlinahh.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://merlinahh.github.io/tags/MongoDB/"}],"author":"Merlin"},{"title":"检测设备系统是否 win7 的函数","slug":"isWin7","date":"2019-06-10T12:04:28.000Z","updated":"2024-02-28T00:41:49.251Z","comments":true,"path":"2019/06/10/isWin7/","link":"","permalink":"https://merlinahh.github.io/2019/06/10/isWin7/","excerpt":"","text":"用于检测用户设备的函数，传入v 12345678910111213141516171819202122232425262728293031323334353637function isWin7(v) &#123; const userAgent = navigator.userAgent.toLowerCase(); let version; if (userAgent.includes(&quot;win&quot;)) &#123; version = &quot;Windows&quot;; if (userAgent.includes(&quot;windows nt 5.0&quot;)) &#123; version = &quot;Windows 2000&quot;; &#125; else if ( userAgent.includes(&quot;windows nt 5.1&quot;) || userAgent.includes(&quot;windows nt 5.2&quot;) ) &#123; version = &quot;Windows XP&quot;; &#125; else if (userAgent.includes(&quot;windows nt 6.0&quot;)) &#123; version = &quot;Windows Vista&quot;;、 &#125; else if ( userAgent.includes(&quot;windows nt 6.1&quot;) || userAgent.includes(&quot;windows 7&quot;) ) &#123; version = &quot;Windows 7&quot;; &#125; else if ( userAgent.includes(&quot;windows nt 6.2&quot;) || userAgent.includes(&quot;windows 8&quot;) ) &#123; version = &quot;Windows 8&quot;; &#125; else if (userAgent.includes(&quot;windows nt 6.3&quot;)) &#123; version = &quot;Windows 8.1&quot;; &#125; else if ( userAgent.includes(&quot;windows nt 6.2&quot;) || userAgent.includes(&quot;windows nt 10.0&quot;) ) &#123; version = &quot;Windows 10&quot;; &#125; else &#123; version = &quot;Unknown&quot;; &#125; &#125; return version === v||&quot;Windows 7&quot;;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://merlinahh.github.io/tags/js/"},{"name":"笔记","slug":"笔记","permalink":"https://merlinahh.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Merlin"},{"title":"Linux 系统安装及升级 node / yarn","slug":"Linux-install-node-yarn","date":"2019-03-05T04:50:02.000Z","updated":"2022-02-16T22:22:26.705Z","comments":true,"path":"2019/03/05/Linux-install-node-yarn/","link":"","permalink":"https://merlinahh.github.io/2019/03/05/Linux-install-node-yarn/","excerpt":"","text":"安装 yarn + node在 CentOS 7.4 系统上安装 yarn，先建立一个 yum repo 的文件 1curl --silent --location https://dl.yarnpkg.com/rpm/yarn.repo | sudo tee /etc/yum.repos.d/yarn.repo 安装 node1sudo yum install -y nodejs 安装yarn1234yum search yarn 搜索 yarn 软件包yum info yarn 显示当前的 yarn 软件包信息yum install yarn 安装 yarn 软件包yarn --version 显示已安装的 yarn 软件包版本信息 升级 node 安装 node 管理器 n 1yarn global add n 查找 node 安装位置 12which node data/home/server/nodejs 编辑环境变量配置文件 123vim ~/.bash_profile export N_PREFIX=/data/home/server/nodejs #node 实际安装位置 export PATH=$N_PREFIX/bin:$PATH :wq 保存退出 1source ~/.bash_profile 确认环境变量是否生效 12echo $N_PREFIX /data/home/server/nodejs n 模块常用命令 n 查看已安装版本 n latest 安装 node 最新版本 n -a x86 latest As above but force 32 bit architecture n stable 安装稳定版 n lts Install or activate the latest LTS node release n 安装指定版本 n use [args …] 使用指定版本 n bin Output bin path for n rm &lt;version …&gt; 删除指定版本 n prune Remove all versions except the current version n –latest Output the latest node version available n –stable Output the latest stable node version available n –lts Output the latest LTS node version available n ls Output the versions of node available yarn 与 npmyarn的简介Yarn是facebook发布的一款取代npm的包管理工具。 yarn的特点速度超快。Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。 超级安全。在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。 超级可靠。使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。 yarn的安装下载node.js，使用npm安装： 1npm install -g yarn 查看版本： 1yarn --version 安装node.js,下载yarn的安装程序: 提供一个.msi文件，在运行时将引导您在Windows上安装Yarn Yarn 淘宝源安装，分别复制粘贴以下代码行到黑窗口运行即可 123yarn config set registry https://registry.npm.taobao.org -gyarn config set sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g yarn的常用命令安装yarn： 1npm install -g yarn 安装成功后，查看版本号： 1yarn --version 创建文件夹 yarn： 1md yarn 进入yarn文件夹： 1cd yarn 初始化项目： 1yarn init // 同npm init，执行输入信息后，会生成package.json文件 yarn的配置项1234yarn config list // 显示所有配置项yarn config get &lt;key&gt; //显示某配置项yarn config delete &lt;key&gt; //删除某配置项yarn config set &lt;key&gt; &lt;value&gt; [-g|--global] //设置配置项 安装包123456yarn install //安装package.json里所有包，并将包及它的所有依赖项保存进yarn.lockyarn install --flat //安装一个包的单一版本yarn install --force //强制重新下载所有包yarn install --production //只安装dependencies里的包yarn install --no-lockfile //不读取或生成yarn.lockyarn install --pure-lockfile //不生成yarn.lock 添加包（会更新package.json和yarn.lock）123yarn add [package] // 在当前的项目中添加一个依赖包，会自动更新到package.json和yarn.lock文件中yarn add [package]@[version] // 安装指定版本，这里指的是主要版本，如果需要精确到小版本，使用-E参数yarn add [package]@[tag] // 安装某个tag（比如beta,next或者latest） 不指定依赖类型默认安装到dependencies里，你也可以指定依赖类型： 123yarn add --dev/-D // 加到 devDependenciesyarn add --peer/-P // 加到 peerDependenciesyarn add --optional/-O // 加到 optionalDependencies 默认安装包的主要版本里的最新版本，下面两个命令可以指定版本： 12yarn add --exact/-E // 安装包的精确版本。例如yarn add foo@1.2.3会接受1.9.1版，但是yarn add foo@1.2.3 --exact只会接受1.2.3版yarn add --tilde/-T // 安装包的次要版本里的最新版。例如yarn add foo@1.2.3 --tilde会接受1.2.9，但不接受1.3.0 发布包1yarn publish 移除一个包1yarn remove &lt;packageName&gt; 移除一个包，会自动更新package.json和yarn.lock 更新一个依赖1yarn upgrade 用于更新包到基于规范范围的最新版本 运行脚本1yarn run 用来执行在 package.json 中 scripts 属性下定义的脚本 显示某个包的信息1yarn info &lt;packageName&gt; 可以用来查看某个模块的最新版本信息 缓存1234yarn cacheyarn cache list # 列出已缓存的每个包 yarn cache dir # 返回 全局缓存位置 yarn cache clean # 清除缓存","categories":[{"name":"服务器","slug":"服务器","permalink":"https://merlinahh.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://merlinahh.github.io/tags/Linux/"},{"name":"Node.js","slug":"Node-js","permalink":"https://merlinahh.github.io/tags/Node-js/"},{"name":"yarn","slug":"yarn","permalink":"https://merlinahh.github.io/tags/yarn/"}],"author":null},{"title":"Linux scp命令","slug":"Linux-scp","date":"2019-03-02T06:45:37.000Z","updated":"2024-02-28T00:43:45.212Z","comments":true,"path":"2019/03/02/Linux-scp/","link":"","permalink":"https://merlinahh.github.io/2019/03/02/Linux-scp/","excerpt":"","text":"Linux scp 命令用于 Linux 之间复制文件和目录。 scp 是 secure copy 的缩写, scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。 scp 是加密的，rcp 是不加密的，scp 是 rcp 的加强版。 语法 123scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file][-l limit] [-o ssh_option] [-P port] [-S program][[user@]host1:]file1 [...] [[user@]host2:]file2 简易写法: 1scp [可选参数] file_source file_target 参数说明： 1234567891011121314151617-1： 强制scp命令使用协议ssh1-2： 强制scp命令使用协议ssh2-4： 强制scp命令只使用IPv4寻址-6： 强制scp命令只使用IPv6寻址-B： 使用批处理模式（传输过程中不询问传输口令或短语）-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）-p：保留原文件的修改时间，访问时间和访问权限。-q： 不显示传输进度条。-r： 递归复制整个目录。-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，-P port：注意是大写的P, port是指定数据传输用到的端口号-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 实例 从本地复制到远程命令格式： 1scp local_file remote_username@remote_ip:remote_folder 或者 1scp local_file remote_username@remote_ip:remote_file 或者 1scp local_file remote_ip:remote_folder 或者 1scp local_file remote_ip:remote_file 第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名； 第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名； 应用实例： 1234scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music/001.mp3 scp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music scp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music/001.mp3 复制目录命令格式： 1scp -r local_folder remote_username@remote_ip:remote_folder 或者 1scp -r local_folder remote_ip:remote_folder 第1个指定了用户名，命令执行后需要再输入密码； 第2个没有指定用户名，命令执行后需要输入用户名和密码； 应用实例： 12scp -r /home/space/music/ root@www.runoob.com:/home/root/others/ scp -r /home/space/music/ www.runoob.com:/home/root/others/ 上面命令将本地 music 目录复制到远程 others 目录下。 从远程复制到本地从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例 应用实例： 12scp root@www.runoob.com:/home/root/others/music /home/space/music/1.mp3 scp -r www.runoob.com:/home/root/others/ /home/space/music/ 说明 如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：12#scp 命令使用端口号 4588scp -P 4588 remote@www.runoob.com:/usr/local/sin.sh /home/administrator 使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。","categories":[{"name":"服务器","slug":"服务器","permalink":"https://merlinahh.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://merlinahh.github.io/tags/Linux/"},{"name":"scp","slug":"scp","permalink":"https://merlinahh.github.io/tags/scp/"}],"author":"Merlin"},{"title":"时间戳转时间格式函数","slug":"timestamp-to-time","date":"2019-02-17T06:47:51.000Z","updated":"2022-02-17T07:41:48.608Z","comments":true,"path":"2019/02/17/timestamp-to-time/","link":"","permalink":"https://merlinahh.github.io/2019/02/17/timestamp-to-time/","excerpt":"","text":"封装好项目需要用到时可以直接调用的函数 123456789101112131415161718function timestampToTime(timestamp) &#123; const date = new Date(timestamp * 1000); // 时间戳为10位需*1000, 时间戳为13位的话不需乘1000 const Y = date.getFullYear() + &quot;-&quot;; const M = (date.getMonth() + 1 &lt; 10 ? &quot;0&quot; + (date.getMonth() + 1) : date.getMonth() + 1) + &quot;-&quot;; const D = (date.getDate() &lt; 10 ? &quot;0&quot; + date.getDate() : date.getDate()) + &quot; &quot;; const h = (date.getHours() &lt; 10 ? &quot;0&quot; + date.getHours() : date.getHours()) + &quot;:&quot;; const m = (date.getMinutes() &lt; 10 ? &quot;0&quot; + date.getMinutes() : date.getMinutes()) + &quot;:&quot;; const s = date.getSeconds() &lt; 10 ? &quot;0&quot; + date.getSeconds() : date.getSeconds(); return Y + M + D + h + m + s;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://merlinahh.github.io/tags/js/"},{"name":"笔记","slug":"笔记","permalink":"https://merlinahh.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Merlin"},{"title":"Linux 用户管理及用户权限设置","slug":"Linux-user-sudo","date":"2019-02-17T00:49:41.000Z","updated":"2024-02-28T00:43:56.557Z","comments":true,"path":"2019/02/17/Linux-user-sudo/","link":"","permalink":"https://merlinahh.github.io/2019/02/17/Linux-user-sudo/","excerpt":"","text":"Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。 每个用户账号都拥有一个惟一的用户名和各自的口令。 用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 实现用户账号的管理，要完成的工作主要有如下几个方面： 用户账号的添加、删除与修改。 用户口令的管理。 用户组的管理。 注：此说明适用于Debian、Redhat、suse、Ubuntu、Fedora等众多linux系统，并对多少位没有区别。 用户分类： 超级用户 UID=0 root 普通用户 UID500起。由超级用户或者具有超级用户权限的用户创建的用户 虚拟用户 UID 1-499 存在满足文件或服务启动的需要。一般不能登录系统，只是傀儡 用户关联的四个文件：/etc/passwd /etc/shadow /etc/group /etc/gshadow 一、管理用户命令汇总： 命令 说明 useradd 同adduser命令，执行此命令可在系统中添加用户 userdel 删除用户及相关用户的配置文件 passwd 为用户设置密码。更改/etc/shadow chage 修改用户密码有效期限。管理/etc/shadow usermod 修改用户命令，可以通过usermod来修改登录名，用户的家目录等等 id 查看用户的UID , GID及所归属的用户组 su 用户角色切换命令 sudo sudo是通过另一个用户来执行命令，su是用户来切换用户，然后通过切换到的用户来完成相应的任务，但sudo能在命令后面直接接命令执行，如：sudo ls /root，不需要root密码就可以执行只有root才能执行相应的命令或具备的目录权限；这个权限需要通过visudo命令或编辑/etc/sudoers来实现 visudo visudo配置sudo权限的编辑命令；也可以不用这个命令，直接用vi来编辑/etc/sudoers实现。但推荐用visudo来操作（会自动检查语法） 其它与用户管理相关的命令，可了解，但不要深入研究！掌握重点即可！ 二、/etc/skel 目录12345678root@ubuntu:/# ll -a /etc/skel total 40 drwxr-xr-x 2 root root 4096 Dec 1 10:13 ./ drwxr-xr-x 142 root root 12288 Jan 25 16:19 ../ -rw-r--r-- 1 root root 220 Sep 1 2015 .bash_logout -rw-r--r-- 1 root root 3771 Sep 1 2015 .bashrc -rw-r--r-- 1 root root 8980 Apr 20 2016 examples.desktop -rw-r--r-- 1 root root 655 May 16 2017 .profile 作用：/etc/skel 目录是用来存放新用户配置文件的目录，当我们添加新用户时，这个目录下的所有文件会自动被复制到新添加的用户的家目录下；默认情况下/etc/skel 目录下的所有文件都是隐藏文件（以点开头的文件）；通过修改，添加，删除/etc/skel目录下的文件，我们可为新创建的用户提供统一的，标准的，初始化用户环境。 企业面试题：当新建了一个用户，该用户登录时出现如下提示：请问是什么原因？如何解决？ 123[root@gin ~]# su - gin -bash-4.1$ -bash-4.1$ 解答：出现这种情况的原因是环境变量有问题，解决方案就是拷贝/etc/skel目录下以bash开头的文件到当前用户的家目录即可！ 1234[root@centos home]# mkdir /home/gin[root@centos home]# cp -a /etc/skel/.bash* ./gin[root@centos home]# chmod -R 700 gin[root@centos home]# chown gin:gin -R gin 三、/etc/login.defs配置文件/etc/login.defs 是设置用户帐号限制的文件。该文件里的配置对root用户无效。 如果/etc/shadow文件里有相同的选项，则以/etc/shadow里的设置为准，也就是说/etc/shadow的配置优先级高于/etc/login.defs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# *REQUIRED* required# Directory where mailboxes reside, _or_ name of file, relative to the# home directory. If you _do_ define both, MAIL_DIR takes precedence.# QMAIL_DIR is for Qmail##QMAIL_DIR MaildirMAIL_DIR /var/spool/mail#创建用户时，要在目录/var/spool/mail中创建一个用户mail文件#MAIL_FILE .mail # Password aging controls:## PASS_MAX_DAYS Maximum number of days a password may be used.# PASS_MIN_DAYS Minimum number of days allowed between password changes.# PASS_MIN_LEN Minimum acceptable password length.# PASS_WARN_AGE Number of days warning given before a password expires.#PASS_MAX_DAYS 99999#密码最大有效期PASS_MIN_DAYS 0#两次修改密码的最小间隔时间PASS_MIN_LEN 5#密码最小长度，对于root无效PASS_WARN_AGE 7#密码过期前多少天开始提示## Min/max values for automatic uid selection in useradd#创建用户时不指定UID的话自动UID的范围UID_MIN 500#用户ID的最小值UID_MAX 60000#用户ID的最大值## Min/max values for automatic gid selection in groupadd#自动组ID的范围GID_MIN 500#组ID的最小值GID_MAX 60000#组ID的最大值 ## If defined, this command is run when removing a user.# It should remove any at/cron/print jobs etc. owned by# the user to be removed (passed as the first argument).##USERDEL_CMD /usr/sbin/userdel_local#当删除用户的时候执行的脚本 ## If useradd should create home directories for users by default# On RH systems, we do. This option is overridden with the -m flag on# useradd command line.#CREATE_HOME yes#使用useradd的时候是够创建用户目录 # The permission mask is initialized to this value. If not specified,# the permission mask will be initialized to 022.UMASK 077 # This enables userdel to remove user groups if no members exist.#USERGROUPS_ENAB yes#用MD5加密密码 为什么新建用户时会从该目录下拷贝文件到用户家目录呢？因为有/etc/default/useradd文件的存在！~ 四、/etc/default/useradd 文件/etc/default/useradd 文件是在使用useradd添加用户时的一个需要调用的一个默认的配置文件，可以使用“useradd -D”参数，这样的命令格式来修改文件里的内容。该文件的内容如下： 123456789[root@gin gin]# cat /etc/default/useradd# useradd defaults fileGROUP=100 ## 表示 用户组ID （依赖于/etc/login.defs的USERGROUPS_ENAB参数，如果为no，则由此处控制）HOME=/home ## 把用户家目录建在/home中INACTIVE=-1 ## 是否启用账号过期停权，-1表示不启用EXPIRE= ## 账号是否启用过期设置 无表示不启用SHELL=/bin/bash ## 账号使用shell种类SKEL=/etc/skel ## 配置新用户目录的默认文件存放路径CREATE_MAIL_SPOOL=yes ## 是否创建邮箱缓存 yes表示创建 如：修改EXPIRE的值为2015/06/10： 12345678910[root@Gin scripts]# useradd -D -e 2015/06/10[root@Gin scripts]# cat /etc/default/useradd# useradd defaults fileGROUP=100HOME=/homeINACTIVE=-1EXPIRE=2015/06/10SHELL=/bin/bashSKEL=/etc/skelCREATE_MAIL_SPOOL=yes 五、Linux系统用户账号的管理用户账号的管理工作主要涉及到用户账号的添加、修改和删除。添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。 useradd命令修改的文件：/etc/passwd , /etc/shadow , /etc/group , /etc/gshadow 控制useradd命令默认行为的文件：/etc/default/useradd , /etc/login.defs 添加新的用户账号当使用useradd命令不加参数选项，后面直接跟所添加的用户名时，系统首先会读取配置文件/etc/login.defs and /etc/default/useradd中的定义的参数或规则，根据设置的规则添加用户，同时会向/etc/passwd and /etc/group文件添加新建用户和用户组记录。 当然/etc/passwd and /etc/group的加密资讯文件/etc/shadow and /etc/gshadow也会同步生成记录，同时系统还会根据/etc/default/useradd文件中所配置的信息建立用户的家目录，并复制/etc/skel中的所有文件（包括隐藏的环境配置文件）到新用户的家目录中。 添加新用户帐号使用useradd命令，其语法及选项如下： 1useradd 选项 用户名 -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 -e expire_date 账号终止日期，日期的指定格式为 MM/DD/YY -f inactive_days 账号过期几日后永久停权。当值为0时账号则立刻停权。为-1时则关闭此功能，预设值为-1 -m 自动建立用户的登入目录。 -M 不要自动建立用户的登入目录。 -n 取消建立以用户名称为名的群组。 -r 创建系统账户 例1：-d , -m参数的使用1useradd –d /home/olcs -m sam 此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录/home/olcs（/home为默认的用户主目录所在的父目录）。 例2：-s , -G参数的使用1useradd -s /bin/bash -g olcs –G olcs,root gem 此命令新建了一个用户gem，该用户的登录Shell是/bin/bash，它属于olcs用户组，同时又属于root用户组，其中olcs用户组是其主组。 例3：-e参数的使用 （指定账户什么时候过期）1234[root@Andy andy]# date -s 01/18/2012 #修改系统时间[root@Andy andy]# useradd tmpuser1 -e 01/19/12 #增加一个tmpuser1用户，并指定2012年1月19号过期[root@Andy andy]# date -s 01/21/12Sat Jan 21 00:00:00 CST 2012 #系统更改时间为2012年1月21号，而上面建立的用户过期时间是2012年1月19号，此时切换到tmpuser1用户，发现还是可以登录 12345678[root@Andy andy]# chage -l tmpuser1Last password change : Jan 17, 2012Password expires : neverPassword inactive : neverAccount expires : Jan 19, 2012 #过期时间的确是19号，设置没错Minimum number of days between password change : 0Maximum number of days between password change : 99999Number of days of warning before password expires : 7 为什么还是可以切换到tmpuser1用户呢？1）通过-e设置后无法远程SSH连接，但是可以用 su 切换，账户并未被锁定2）账户过期时间和系统时间，需要相差2天(该测试是在CentOS5.x版本，CentOS6版本不相差2天)再次测试： 12[root@Andy andy]# useradd tmpuser2 -e 01/22/12[root@Andy andy]# passwd tmpuser2 我们在SSH客户端用tmpuser2登录，不要用su进行切换！为了让账户过期，我们再次修改系统时间 1234[root@Andy andy]# date -s 01/23/12[root@Andy andy]# clock -w #重新读取系统时间[root@Andy andy]# date +%F2012-01-23 当tmpuser2账户退出登录后，再次登录时，就会提示： Your account has expired; please contact your system administrator 用户的过期时间当然也可以使用usermod命令来修改： 1[root@gin gin]# usermod -e &quot;216/10/10&quot; zhangsansan 指定用户过期时间 例4：useradd -c -u -G -s -d 多个参数组合例子自定义用户的家目录，shell类型，所归属的用户组等：添加用户poe6，并设置其用户注释信息为HandsomeBoy，UID指定为806，归属为用户组root , poe , sa成员，其shell类型为/bin/sh，设置家目录为/poe6 [root@gin gin]# useradd -c “HandsomeBoy” -u 806 -G root,poe,sa -s /bin/sh -d /poe6 poe6 这三个组必须要先存在增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。 Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。 生产场景中创建用户的完整命令： 1234567[root@Andy andy]# groupadd -g 801 sa[root@Andy andy]# useradd -g sa -u 901 ett[root@Andy andy]# echo &quot;who123&quot;|passwd --stdin ettChanging password for user ett.passwd: all authentication tokens updated successfully.[root@Andy andy]# visudo -c[root@Andy andy]# history -c 删除帐号如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。删除一个已有的用户账号使用userdel命令，其格式如下： 1userdel 选项 用户名 常用的选项是-r，它的作用是把用户的主目录一起删除。 例如： 1userdel -r olcs 此命令删除用户olcs在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。 修改帐号修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。 修改已有用户的信息使用usermod命令，其格式如下： 1usermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。 另外，有些系统可以使用如下选项： usermod参数选项 注释说明 -c comment 增加用户账号/etc/passwd中的注解说明栏（第5栏） -d home_dir 更新用户新的家目录，组合-m选项，用户旧的家目录会搬到新的家目录去，如旧的家目录不存在则创建新的家目录 -e expire_date 加上用户账号停止日期。格式为MM/DD/YY -f inactive_days 账号过期几日后永久停权。当值为0时账号则立刻被停权。而当值为-1时则关闭此功能。预设值为-1 -g initial_group 更新用户的起始登入用户组。用户组名须已存在。用户组ID必须参照既有的用户组，用户组ID预设值为1 -G group.[..] 定义用户为一堆groups的成员，每个用户组使用逗号分隔 -l login_name 修改用户login时的名称为login_name，其余信息不变 -s shell 指定登录shell -u uid 指定用户UID值。除非接-o参数（usermode -u 505 -o andy），否则ID值必须是唯一的数字（不能为负数） -L 冻结用户的密码。实际就是间接修改/etc/shadow的密码栏。在密码栏的开头加上！号，即表示冻结。这个冻结密码的功能和usermod -e , useradd -e , chage -E , passwd -l 等命令参数都有类似的功效，那就是让用户无法正常登陆 -U 取消冻结的密码，使之恢复登陆，实际同样是修改/etc/shadow的密码栏，在密码栏的开头取消“！ ”号，即表示恢复 实例1：usermod -c修改/etc/passwd中用户的说明栏12345[root@bruce bruce]# tail -1 /etc/passwd #--&gt;为了进行对比，在修改前进行查看andy:x:802:803::/home/andy:/bin/bash[root@centos andy]# usermod -c &quot;AndyLaw&quot; andy[root@bruce bruce]# tail -1 /etc/passwdandy:x:802:803:AndyLaw:/home/andy:/bin/bash 实例2：测试 -c , -u , -G , -s , -d等参数！要求添加用户andy6，并设置用户注释为HandsomeBoy，UID指定为806，归属为用户组root，andy , sa成员，其shell类型为/bin/sh，设置家目录为/andy612345[root@bruce bruce]# useradd -c HandsomeBoy -u 806 -s /bin/sh -G root,andy,sa -d /andy6 andy6[root@bruce bruce]# grep andy6 /etc/passwdandy6:x:806:806:HandsomeBoy:/andy6:/bin/sh[root@bruce bruce]# id andy6uid=806(andy6) gid=806(andy6) groups=806(andy6),0(root),803(andy),804(sa) 提示：在添加新用户时，如果不使用-n参数，系统会自动创建一个与用户同名的用户组，如本例就自动生成了一个andy6的用户组 下面使用usermod命令进行修改 : 要求注释改为uptowngirl，UID修改为1806，归属修改为用户组root , sa成员，其shell类型修改为/bin/tcsh，设置家目录为/tmp/andy6： 1[root@bruce bruce]# usermod -c uptowngirl -u 1806 -G root,sa -s /bin/tcsh -d /tmp/andy6 实例3：使用户在2016-11-15后过期 usermod -e123456789[root@bruce bruce]# usermod -e 2016-11-26 andy6[root@bruce bruce]# chage -l andy6Last password change : Nov 24, 2016Password expires : neverPassword inactive : neverAccount expires : Nov 26, 2016Minimum number of days between password change : 0Maximum number of days between password change : 99999Number of days of warning before password expires : 7 实例4：冻结andy6用户的密码 usermod -L123456[root@bruce bruce]# grep andy6 /etc/shadowandy6:$6$V/bwRYJd$aUnJt/DUupmwv00G8kCzmqg61Z0GWCU7aNp7rgeA.YFb2PROvqcZM.WVIlqZjesmIfQgoJR/QoL6b.VdrLybd.:17129:0:99999:7::17131:[root@bruce bruce]# usermod -L andy6[root@bruce bruce]# grep andy6 /etc/shadowandy6:!$6$V/bwRYJd$aUnJt/DUupmwv00G8kCzmqg61Z0GWCU7aNp7rgeA.YFb2PROvqcZM.WVIlqZjesmIfQgoJR/QoL6b.VdrLybd.:17129:0:99999:7::17131:[root@bruce bruce]# usermod -U andy6 用户口令的管理用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。 指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为： 1passwd 选项 用户名 可使用的选项： -l , --lock 锁定口令，即禁用账号。 -u , --unlock 口令解锁。 -d , --delete 使账号无口令。 -f , --force 强迫用户下次登录时修改口令。 --stdin 从stdin读入密码 (root only) , 如果默认用户名，则修改当前用户的口令。 -n , --minimun=DAYS 两次密码修改的最小天数，后面接数字，仅root权限操作 -x , --maximun=DAYS 两次密码修改的最大天数，后面接数字，仅root权限操作 -w , --warning=DAYS 在距多少天提醒用户修改密码，仅root权限操作 -i ，--inactive=DASY 在密码过期后多少天，用户被禁掉，仅root权限操作 -S , --status 查询用户的密码状态，仅root权限操作 实例1：我们用-l参数来锁定andy用户，使之不能修改密码，然后再用-u参数来解除锁定123456789[root@bruce bruce]# passwd -S andy #锁定前查看andy账户的状态andy PS 2016-11-24 0 99999 7 -1 (Password set, SHA512 crypt.)[root@bruce bruce]# grep andy /etc/shadow #查看andy账户的密码状态andy:$6$i5dcb9oB$6U2HlaHJqIVZWZNElMgzab.Y7M5nALaE/PT54kq2hrrP6hGjmbQhoqVktDTlX5Kxt.JyB.RNlm.7PkYFO7odG0:17129:0:99999:7:::[root@bruce bruce]# passwd -l andyLocking password for user andy.passwd: Success[root@bruce bruce]# grep andy /etc/shadow #再次查看密码状态，发现密码前多了两个!!号andy:!!$6$i5dcb9oB$6U2HlaHJqIVZWZNElMgzab.Y7M5nALaE/PT54kq2hrrP6hGjmbQhoqVktDTlX5Kxt.JyB.RNlm.7PkYFO7odG0:17129:0:99999:7::: #锁定之后，用andy账户登录系统，再修改密码会提示： 12[andy@bruce ~]$ passwdpasswd: Authentication token manipulation error #解除锁定 12345[root@bruce bruce]# passwd -u andyUnlocking password for user andy.passwd: Success[root@bruce bruce]# grep andy /etc/shadow #解除锁定后，/etc/shadow文件中密码字段前面两个！！号消失andy:$6$i5dcb9oB$6U2HlaHJqIVZWZNElMgzab.Y7M5nALaE/PT54kq2hrrP6hGjmbQhoqVktDTlX5Kxt.JyB.RNlm.7PkYFO7odG0:17129:0:99999:7::: 实例2：举一个组合参数-x -n -w -i控制密码时效的例子。要求andy用户7天内不能更改密码，60天以后必须修改密码，过期前10天通知andy用户，过期后30天后禁止用户登陆123[root@bruce bruce]# passwd -n 7 -x 60 -w 10 -i 30 andyAdjusting aging data for user andy.passwd: Success #当然使用chage命令也可以实现同样的效果只是参数略有不同：chage -m 7 -M 60 -W 10 -I 30 andy 在root账户下修改andy的密码，然后回到andy账户，再次修改密码出现如下提示： passwd: Authentication token manipulation error 例如，假设当前用户是olcs，则下面的命令修改该用户自己的口令： 1234$ passwdOld password:******New password:*******Re-enter new password:******* 如果是超级用户，可以用下列形式指定任何用户的口令： 123# passwd olcsNew password:*******Re-enter new password:******* 普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。 为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。 为用户指定空口令时，执行下列形式的命令： 1# passwd -d sam 此命令将用户sam的口令删除，这样用户sam下一次登录时，系统就不再询问口令。passwd命令还可以用-l(lock)选项锁定某一用户，使其不能登录，例如： 1# passwd -l olcs –stdin方式修改设置密码 1234567[root@gin gin]# echo 123456|passwd --stdin ginChanging password for user gin.passwd: all authentication tokens updated successfully.[root@gin gin]# echo 123 &gt; p.log[root@gin gin]# passwd --stdin gin &lt; p.logChanging password for user gin.passwd: all authentication tokens updated successfully. 备注：/usr/bin/passwd 是修改用户密码的程序 密码记录在 /etc/shadow /etc/passwd是用户数据库，其中的域给出了用户名、加密口令和用户的其他信息. /etc/shadow是在安装了影子(shadow)口令软件的系统上的影子口令文件。影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow中，而后者只对超级用户( r o o t )可读。 Linux /etc/shadow文件中的记录行与/etc/passwd中的一一对应,它由pwconv命令根据/etc/passwd中的数据自动产生。 口令时效口令时效是系统管理员用来防止机构内不良口令的一种技术。在Linux系统上，口令时效是通过chage命令来管理的，格式为： 1chage [option] username 下面列出了chage命令的选项说明： -m days： 指定用户必须改变口令所间隔的最少天数。如果值为0，口令就不会过期。 -M days： 指定口令有效的最多天数。当该选项指定的天数加上-d选项指定的天数小于当前的日期时，用户在使用该帐号前就必须改变口令。 -d days： 指定从1970年1月1日起，口令被改变的天数。 -E date： 指定帐号被锁的日期。日期格式YYYY-MM-DD。若不用日期，也可以使用自1970年1月1日后经过的天数。 -W days： 指定口令过期前要警告用户的天数。 -I --inactive： 在密码过期后多少天，用户被禁掉，仅能以root操作 -l --list ：显示账户年龄信息 该命令记住两个参数-E , -l即可，其它的选项可以使用passwd来替代！ 例如下面的命令要求用户user1两天内不能更改口令，并且口令最长的存活期为30天，口令过期前5天通知用户 1chage -m 2 -M 30 -W 5 user1 可以使用如下命令查看用户user1当前的口令时效信息：chage -l user1 提示： 1）可以使用chage 进入交互模式修改用户的口令时效。 2）修改口令实质上就是修改影子口令文件/etc/shadow中与口令时效相关的字段值。 Linux系统用户组的管理每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。 参数选项 注释说明 -g 指定用户组GID值。除非接-o参数（如：groupadd -g 1234 -o andy），否则ID值必须是唯一的数字（不能为负数）。如果不指定-g参数，则预设值会从500开始。 -r 建立系统用户组。GID值会比/etc/login.defs中定义的UID_MIN值小。如：groupadd -r ett;grep ett /etc/group #–&gt;分号分隔两个命令 ett:x:105: #–&gt;GID为105，小于500了 -f 新增一个账户，强制覆盖一个已经存在的用户组账号。 增加一个新的用户组增加一个新的用户组使用groupadd命令，其格式如下： 1groupadd 选项 用户组 可以使用的选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 例1：1# groupadd olcs 此命令向系统中增加了一个新组olcs，新组的组标识号是在当前已有的最大组标识号的基础上加1。 例2：1#groupadd -g 101 group1 此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。 删除已有用户组如果要删除一个已有的用户组，使用groupdel命令，其格式如下： 1groupdel 用户组 例如： 1#groupdel group1 此命令从系统中删除组group1。 修改用户组的属性修改用户组的属性使用groupmod命令。其语法如下： 1groupmod 选项 用户组 常用的选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字 例1：1# groupmod -g 102 group1 此命令将组group1的组标识号修改为102。 例2：1# groupmod –g 10000 -n group2 group1 此命令将组group1的标识号改为10000，组名修改为group2。 用户在用户组间切换如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如： 1$ newgrp root 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。让Linux系统中的普通用户也有超级用户的权限 目录权限管理3种基本权限在Linux中，将使用系统资源的人员分为4类：超级用户、文件或目录的属主、属主的同组人和其他人员。超级用户拥有对Linux系统一切操作权限，对于其他3类用户都要指定对文件和目录的访问权限。 代表字符 对应数值 权限 对文件的含义 对目录的含义 r 4 读 可以读文件的内容 可以列出目录中的文件列表 w 2 写 可以修改该文件 可以在目录中创建删除文件 x 1 可执行 可以执行该文件 可以使用cd命令进入该目录 - 0 无 查看文件和目录的权限可以使用带l参数的ls命令查看文件或目录的权限 12345[root@Gin scripts]# ll /gintotal 12drwxr-xr-x 2 root root 4096 Jan 28 23:15 pythondrwxr-xr-x 2 root root 4096 Feb 1 13:11 scriptsdrwxr-xr-x 5 root root 4096 Jan 25 18:01 tools 每一行显示一个文件或目录的信息，这些信息包括文件的类型、文件的权限、文件的属主和文件的所属组，还有文件的大小以及创建时间和文件名。输出列表中每 一行第一列的第一个字母指示了该文件的类型。各种文件类型及代表字符如下： -：普通文件 b：块文件设备，是特殊的文件类型 d：目录文件 ，事实上在ext2fs中，目录是一个特殊的文件 c：字符文件设备 ，是特殊的文件类型 l：符号链接文件，实际上它指向另一个文件 s、p：管道文件，这些文件关系到系统的数据结构和管道，通常很少见到 第一列的其余9个字母可分为三组，3个字母一组，这3组分别代表：文件属主的权限、文件所属组的权限和其他用户的权限。每组中的3个栏位分别表示读、 写、执行权限。 第2～10个字符当中的每3个为一组，左边三个字符表示所有者权限，中间3个字符表示与所有者同一组的用户的权限，右边3个字符是其他用户的权限。这三个一组共9个字符，代表的意义如下： r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。 w(Write,写入)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。 x(eXecute，执行)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。 －：表示不具有该项权限。 更改操作权限（chmod/chown）系统管理员和文件属主可以根据需要来设置文件的权限，有两种设置方法：文字设定法和数值设定法。 文字设定法chomd的文字设定法的格式为： 1chmod [ugoa][+-=][rwxugo] 第1个选项表示要赋予权限的用户，具体说明如下： u：属主 g：所属组用户 o：其他用户 a：所有用户第2个选项表示要进行的操作，具体说明如下： +：增加权限 -：删除权限 =：分配权限，同时将原有权限删除第3个选项是要分配的权限，具体说明如下： r/x/w：允许读取/写入/执行 u/g/o：和属主/所属组用户/其他用户的权限相同例如： 123chmod go -r users //取消组用户和其他用户对文件users的读取权限chmod u+x users //对文件users的属主增加招待权限chmod u+x,go-r users //对文件users的属主添加执行权限，同时取消组用户和其他用户对文件的读取权限 数值设定法chmod的数值设定法的格式为：chmod n1n2n3其中n1、n2、n3分别代表属主的权限、组用户的权限和其他用户的权限，这三个选项都是八进制数字。 例如： 12chmod 755 adduser //对文件adduser的属设置可读、写和执行的权限，所属组和其他用户只设置读和执行权限，没有写权限chmod 600 user1 //取消组用户和其他用户对文件user1的一切权限（原权限为-rw-rCrC） 备注：如想一次修改某个目录下所有文件的权限，包括子目录中的文件权限也要修改，要使用参数－R表示启动递归处理。 网站搬家特别是从虚拟空间或windows上搬到linux VPS上会出现文件权限问题，通常目录都是755权限，文件是644权限。首先cd到你要修改的网站目录，然后运行如下两个命令即可快速批量修改权限。 12find -type d|xargs chmod 755find -type f|xargs chmod 644 更改属组或同组人改变文件的属主和组可以用chown命令，命令格式为：chown [-R] 。 例如： 123chown osmond user1 //将文件user1的属主改为osmondchown osmond.osmond user1 //将文件user1的属主和组都改成osmondchown -R osmond.osmond mydir //将mydir目录及其子目录下的所有文件或目录的属主和组都改成osmond 设置文件和目录的生成掩码用户可以使用umask命令设置文件夹的默认生成掩码。默认的生成掩码告诉系统当创建一个文件或目录时不应该赋予哪些权限。如果用户将umask命令放在环境文件（.bash_profile）中，就可以控制所有的新建文件或目录的访问权限。其命令格式为：umask [u1u2u3]其中，u1、u2、u3分别表示的是不允许属主有的权限、不允许同组人有的权限和不允许其他人有的权限。 例如： 1umask 022 //设置不允许同组用户和其他用户有写权限 umask //显示当前的默认生成掩码 用法非常简单，只需执行umask 777 命令，便代表屏蔽所有的权限，因而之后建立的文件或目录，其权限都变成000，依次类推。通常root帐号搭配umask命令的数值为022、027和077，普通用户则是采用002，这样所产生的权限依次为755、750、700、775。 用户登录系统时，用户环境就会自动执行rmask命令来决定文件、目录的默认权限。 特殊权限设置SUID、SGID和sticky-bit除了上述的基本权限之外，还有所谓的特殊权限存在。由于特殊权限会拥有一些“特权”，因而用户若无特殊需要，不应该去打开这些权限，避免安全方面出现严重漏洞，甚至摧毁系统。下面列出了3个特殊权限的说明： SUID：当一个设置了SUID位的可执行文件被执行时，该文件以所有者的身份运行，也就是说无论谁来执行这个文件，他都拥有文件所有者的特权，可以任意存取该文件拥有者能使用的全部系统资源。如果所有者是root，那么执行人就有超级用户的特权了。 SGID：当一个设置了SGID位的可执行文件被执行时，该文件将具有所属组的特权，任意存取整个组所能使用的系统资源；若一个目录设置了SGID，则所有被复制到这个目录下的文件，其所属的组都会被重设为和这个目录一样，除非在复制文件时加上-p（preserve，保留文件属性）参数，才能保留原来 所属的群组设置。 sticky-bit：对一个文件设置了sticky-bit之后，尽管其他用户有写权限，也必须由属主执行删除、移动等操作，对一个目录设置了 sticky-bit之后，存放在该目录下的文件仅允许其属主执行删除、移动等操作。 一个设置了SUID的典型例子是passwd程序，它允许普通用户改变自己的口令，这是通过改变/etc/shadow文件的口令字段来实现的。然而系 统管理员决不允许普通用户拥有直接改变/etc/shadow文件的权限。解决方法是将passwd程序设置SUID，当passwd被执行时将拥有超级用户的权限，而passwd程序运行结束又回到普通用户的权限，下面是显示passwd程序的权限： 12[root@Gin scripts]# ll /usr/bin/passwd-rwsr-xr-x. 1 root root 30768 Feb 22 2012 /usr/bin/passwd 一个设置了sticky-bit的典型例子是系统临时文件目录/tmp，这避免了不守法的用户存心搞鬼，恣意乱删其他用户存放的文件。下面显示/tmp 目录的权限： 12[root@Gin scripts]# ll -d /tmpdrwxrwxrwt. 8 root root 4096 Feb 1 18:04 /tmp SUID、SGID和sticky-bit的表示从上面的显示可以看出，SUID是占用属主的x位置为表示的；SGID是占用组的x位置来表示的；sticky-bit是占用其他人的x位置来表示 的。在表示上有大小定之分，假若同时设置执行权限和SUID、SGID和sticky-bit，权限标识字符是小写的；倘若关闭执行权限，则标识字符会变成大写。 设置特殊权限使用chmod命令设置特殊权限，仍然有字符设定法和数值设定法之分。使用字符设定法时，可以使用s和t权限字符， 例如： 123chmod u+s /usr/bin/myapp //为程序/usr/bin/myapp添加SUID权限chmod g+s /home/groupspace //为目录/home/groupspace添加SGID权限chmod o+t /home/share //为目录/home/share添加sticky-bit权限 使用chmod的数值设定法时，要使用4位八进制数值，其中第一位八进制数用于设置特殊权限，后三位八进制数用于设置基本权限。 例如： 123chmod 4755 /usr/bin/myapp //设置SUIDchmod 2755 /home/groupspace //设置SGIDchmod 1755 /home/share //设置sticky-bit","categories":[{"name":"服务器","slug":"服务器","permalink":"https://merlinahh.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://merlinahh.github.io/tags/Linux/"}],"author":"Merlin"},{"title":"Linux 系统 Nginx 安装与配置","slug":"Linux-install-Nginx","date":"2019-02-13T20:29:14.000Z","updated":"2024-02-28T00:43:33.346Z","comments":true,"path":"2019/02/14/Linux-install-Nginx/","link":"","permalink":"https://merlinahh.github.io/2019/02/14/Linux-install-Nginx/","excerpt":"","text":"Nginx 安装系统平台：CentOS release 6.6 (Final) 64位。 一、安装编译工具及库文件1yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 二、首先要安装 PCREPCRE 作用是让 Nginx 支持 Rewrite 功能。 下载 PCRE 安装包，下载地址： http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz 12cd /usr/local/src/wget http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz 解压安装包 1tar zxvf pcre-8.35.tar.gz 3、进入安装包目录 1cd pcre-8.35 编译安装 12./configuremake &amp;&amp; make install 查看pcre版本 1pcre-config --version 安装 Nginx 下载 Nginx，下载地址：https://nginx.org/en/download.html 12cd /usr/local/src/wget http://nginx.org/download/nginx-1.6.2.tar.gz 解压安装包 1tar zxvf nginx-1.6.2.tar.gz 进入安装包目录 1cd nginx-1.6.2 编译安装 123./configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.35makemake install 查看nginx版本 1/usr/local/webserver/nginx/sbin/nginx -v 到此，nginx安装完成。 Nginx 配置创建 Nginx 运行使用的用户 www12/usr/sbin/groupadd www /usr/sbin/useradd -g www www 配置nginx.conf将/usr/local/webserver/nginx/conf/nginx.conf替换为以下内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475cat /usr/local/webserver/nginx/conf/nginx.confuser www www;worker_processes 2; #设置值和CPU核心数一致error_log /usr/local/webserver/nginx/logs/nginx_error.log crit; #日志位置和日志级别pid /usr/local/webserver/nginx/nginx.pid;#Specifies the value for maximum file descriptors that can be opened by this process.worker_rlimit_nofile 65535;events&#123; use epoll; worker_connections 65535;&#125;http&#123; include mime.types; default_type application/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; $http_x_forwarded_for&#x27;; #charset gb2312; server_names_hash_bucket_size 128; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 8m; sendfile on; tcp_nopush on; keepalive_timeout 60; tcp_nodelay on; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.0; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml; gzip_vary on; #limit_zone crawler $binary_remote_addr 10m; #下面是server虚拟主机的配置 server &#123; listen 80;#监听端口 server_name localhost;#域名 index index.html index.htm index.php; root /usr/local/webserver/nginx/html;#站点目录 location ~ .*\\.(php|php5)?$ &#123; #fastcgi_pass unix:/tmp/php-cgi.sock; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125; location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf|ico)$ &#123; expires 30d; # access_log off; &#125; location ~ .*\\.(js|css)?$ &#123; expires 15d; # access_log off; &#125; access_log off; &#125;&#125; 检查配置文件nginx.conf的正确性：1/usr/local/webserver/nginx/sbin/nginx -t 启动 Nginx1/usr/local/webserver/nginx/sbin/nginx 访问站点从浏览器访问我们配置的站点ip：显示Welcome to nginx即配置成功 Nginx 其他命令以下包含了 Nginx 常用的几个命令： 123/usr/local/webserver/nginx/sbin/nginx -s reload # 重新载入配置文件/usr/local/webserver/nginx/sbin/nginx -s reopen # 重启 Nginx/usr/local/webserver/nginx/sbin/nginx -s stop # 停止 Nginx","categories":[{"name":"服务器","slug":"服务器","permalink":"https://merlinahh.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://merlinahh.github.io/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"https://merlinahh.github.io/tags/Nginx/"}],"author":"Merlin"},{"title":"Linux 浅尝 —— 网站项目搭建初期知识整理，客户端服务器交互原理","slug":"linux-study","date":"2019-02-13T17:48:25.000Z","updated":"2024-02-28T00:43:52.002Z","comments":true,"path":"2019/02/14/linux-study/","link":"","permalink":"https://merlinahh.github.io/2019/02/14/linux-study/","excerpt":"","text":"服务器目录. /etc 配置文件 /bin 就是常用命令 /home 用户文件的根目录 相当于win的我的文档 /usr 额外安装的linux软件 /srv 一般是我们自己创建的 表示服务 阿里云自带一个空的srv目录 网络所谓网络 本质就是共享数据 起初 主机都是单机的 之所以叫计算机 是因为最早之前只能用来计算 局域网一个主机可以访问另一个主机了 它们互相连接 组成了局域网 互联网再发展就是互联网 但本质上还是一个主机和另一个主机的连接数据交换 客户端和服务端再后来 衍生出来用户和服务 客户端和服务端的概念 主机有很多操作系统：* windoms利用可视化捕获一大批客户端用户 * linux利用高效捕获了服务端的市场 客户端和服务端跟操作系统无关的 每个操作系统都可作为客户端和服务端 所以服务器的定义就是： 接受请求并返回数据的主机 那么就有人给这些主机开发服务器软件 服务器软件就是：处理请求和响应的软件，一般服务器都会存在服务器软件用来提供接受请求并响应 很著名的就是Tomcat (所有的数据库其本质也是自带了服务器功能，主要功能是把数据保存在本地，次要功能也可以接受请求并响应，不需要通过别的软件) 代理在技术多变的今天，客户端和服务端就有很重要的问题 那就是安全 于是就有了 代理 技术 所谓代理，就是客户端不想让服务端知道自己的真实地址，简单理解就是 VPN 这样隐藏了真实的客户端地址和身份 游戏加速器就是这个原理 自己的地址被墙了 我们可以通过代理去请求数据 我们和代理交换数据就可以啦 正向代理 客户端主动访问 服务端被动接受请求 因为正向代理就是保护客户端的 反向代理 客户端请求服务端 服务端用一个向外暴露的服务器去接受 然后转发到真实服务器 保护服务器真实地址 域名和域名服务器它隐藏了真实服务器的ip而暴露一个自定义域名 类似反向代理服务器 域名服务器(DNS服务器)就是提供IP地址和域名之间的转换服务的服务器 域名和IP地址相互映射(这真实ip是在买域名的时候 后台可以设置的 这就叫域名解析) DNS域名解析原理host就是本地DNS 输入网址 客户端首先找本地DNS没找到对应ip才会去网络DNS找 找到之后会带着网址向目标ip请求 浏览器访问服务器原理： 一个服务器请求量过大，服务器的后端程序会内存溢出，导致502 代理ip可分发到多个实际服务器ip 后端有两个解决方式： 分布式 就是把一个服务拆分为多个 一个业务分拆多个子业务，部署到不同的功能服务器，一个挂了就挂了😂 （如果项目不大 它一般安装在和服务同一台服务器里 直接把请求转到本地的服务器软件里） 集群 就是部署多个项目统一管理接受请求 一套项目部署多台服务器，其中一台挂了，其他的可继续访问 假设有多个服务器作为集群 那么怎么保证所有的请求均分而不导致某一个服务器被挤爆呢 （如果项目特大 一般单独安装在一个服务器里 还可以实现负载均衡） ——负载均衡 大型服务主要是解决两个事： 高吞吐就是能承载高并发的请求处理 高可用就是系统的可用程度，包括安全 流畅 不出差错等等 Nginx 反向代理服务器 反向代理服务器是它最最主要的功能，能隐藏掉其服务器真实ip和端口 实现负载均衡 反向代理服务器在做负载均衡来实现所有集群节点的平均分配 HTTP服务器（静态资源服务器） 反向代理服务器可以把请求转到本地的服务器软件里 这个服务器软件可以是Tomcat 也可以是nginx 在前后端分离的时代 也就是现在 前端页面可以丢给nginx做静态映射 后端服务可以交给tomcat 正向代理服务处理发展史 裸奔时代 域名访问 -&gt; 服务商域名解析，通过域名找到ip -&gt; 拿到ip访问tomcat -&gt; 返回页面 DNS轮循 1个域名映射3个ip 自带负载均衡（高吞吐 低可用） 假设一个tomcat的并发量是每秒1000，那么这个服务的并发量就是每秒3000 Nginx 高吞吐 中可用 其中一个tomcat挂掉了，可正常访问，nginx挂掉了就挂掉了 keepalived keepalived实现nginx集群 挂一个还有一个 keepalived+lvs nginx被lvs负载均衡 同时还负载均衡tomcat lvs是操作系统层面 请求不容易超过并发 同时lvs还是集群的 挂掉一个还有 超高并发+超高可用 给nginx集群一个负载均衡 请求会平分到各个nginx 各个nginx再反向代理+负载均衡到各个tomcat Nginx基本命令Linux安装和升级yarn及nodeLinux 命令大全 Linux 命令大全 1、文件管理 cat chattr chgrp chmod chown cksum cmp diff diffstat file find git gitview indent cut ln less locate lsattr mattrib mc mdel mdir mktemp more mmove mread mren mtools mtoolstest mv od paste patch rcp rm slocate split tee tmpwatch touch umask which cp whereis mcopy mshowfat rhmask scp awk read updatedb 2、文档编辑 col colrm comm csplit ed egrep ex fgrep fmt fold grep ispell jed joe join look mtype pico rgrep sed sort spell tr expr uniq wc let 3、文件传输 lprm lpr lpq lpd bye ftp uuto uupick uucp uucico tftp ncftp ftpshut ftpwho ftpcount 4、磁盘管理 cd df dirs du edquota eject mcd mdeltree mdu mkdir mlabel mmd mrd mzip pwd quota mount mmount rmdir rmt stat tree umount ls quotacheck quotaoff lndir repquota quotaon 5、磁盘维护 badblocks cfdisk dd e2fsck ext2ed fsck fsck.minix fsconf fdformat hdparm mformat mkbootdisk mkdosfs mke2fs mkfs.ext2 mkfs.msdos mkinitrd mkisofs mkswap mpartition swapon symlinks sync mbadblocks mkfs.minix fsck.ext2 fdisk losetup mkfs sfdisk swapoff 6、网络通讯 apachectl arpwatch dip getty mingetty uux telnet uulog uustat ppp-off netconfig nc httpd ifconfig minicom mesg dnsconf wall netstat ping pppstats samba setserial talk traceroute tty newaliases uuname netconf write statserial efax pppsetup tcpdump ytalk cu smbd testparm smbclient shapecfg 7、系统管理 adduser chfn useradd date exit finger fwhios sleep suspend groupdel groupmod halt kill last lastb login logname logout ps nice procinfo top pstree reboot rlogin rsh sliplogin screen shutdown rwho sudo gitps swatch tload logrotate uname chsh userconf userdel usermod vlock who whoami whois newgrp renice su skill w id groupadd free 8、系统设置 reset clear alias dircolors aumix bind chroot clock crontab declare depmod dmesg enable eval export pwunconv grpconv rpm insmod kbdconfig lilo liloconfig lsmod minfo set modprobe ntsysv mouseconfig passwd pwconv rdate resize rmmod grpunconv modinfo time setup sndconfig setenv setconsole timeconfig ulimit unset chkconfig apmd hwclock mkkickstart fbset unalias SVGATextMode gpasswd 9、备份压缩 ar bunzip2 bzip2 bzip2recover gunzip unarj compress cpio dump uuencode gzexe gzip lha restore tar uudecode unzip zip zipinfo 10、设备管理 setleds loadkeys rdev dumpkeys MAKEDEV poweroff 其他命令Linux bc 命令 Linux tail 命令 Linux head 命令 Linux xargs 命令 Linux ip 命令 Linux nohup 命令 扩展文章Linux 常用命令全拼","categories":[{"name":"服务器","slug":"服务器","permalink":"https://merlinahh.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://merlinahh.github.io/tags/Linux/"}],"author":"Merlin"},{"title":"删除字符串结尾指定字符","slug":"substring-remove","date":"2019-01-18T04:39:57.000Z","updated":"2022-02-17T04:46:08.710Z","comments":true,"path":"2019/01/18/substring-remove/","link":"","permalink":"https://merlinahh.github.io/2019/01/18/substring-remove/","excerpt":"","text":"需要删除字符串结尾指定字符需求的函数。 123456function TargetEndRemove(string, target) &#123; if (string.substr(-target.length,target.length) == target) &#123; //判断字符串string是否以target结尾 string = string.substring(0,str.lastIndexOf(target)) //若是则删除字符串结尾的target &#125; return string;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://merlinahh.github.io/tags/js/"},{"name":"笔记","slug":"笔记","permalink":"https://merlinahh.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Merlin"},{"title":"Hexo + GitHub Page 指令","slug":"Hexo-GitHub-to-built-a-blog-4","date":"2018-07-13T02:22:40.000Z","updated":"2024-02-28T00:43:17.583Z","comments":true,"path":"2018/07/13/Hexo-GitHub-to-built-a-blog-4/","link":"","permalink":"https://merlinahh.github.io/2018/07/13/Hexo-GitHub-to-built-a-blog-4/","excerpt":"","text":"常用指令init1hexo init [folder] 创建一个网站项目。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 new1hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 1hexo new post &quot;title with whitespace&quot; generate1hexo generate 生成静态文件。 选项 描述 -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 该命令可以简写为 1hexo g publish1hexo publish [layout] &lt;filename&gt; 发表草稿。 server1hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 选项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 deploy1hexo deploy 部署网站。 参数 描述 -g, –generate 部署之前预先生成静态文件 该命令可以简写为： 1hexo d render1hexo render &lt;file1&gt; [file2] ... 渲染文件。 参数 描述 -o, –output 设置输出路径 migrate1hexo migrate &lt;type&gt; 从其他博客系统 迁移内容 clean1hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 list1hexo list &lt;type&gt; 列出网站资料。 version1hexo version 显示 Hexo 版本。 执行选项安全模式1hexo --safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 调试模式1hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 简洁模式1hexo --silent 隐藏终端信息。 自定义配置文件的路径1hexo --config custom.yml 自定义配置文件的路径，执行后将不再使用 _config.yml。 显示草稿1hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 自定义 CWD1hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"GitHub Page","slug":"GitHub-Page","permalink":"https://merlinahh.github.io/tags/GitHub-Page/"},{"name":"HEXO","slug":"HEXO","permalink":"https://merlinahh.github.io/tags/HEXO/"}],"author":"Merlin"},{"title":"Hexo + GitHub Page 修改配置文件 _config.yml","slug":"Hexo-GitHub-to-built-a-blog-3","date":"2018-06-13T01:23:10.000Z","updated":"2024-02-28T00:43:20.073Z","comments":true,"path":"2018/06/13/Hexo-GitHub-to-built-a-blog-3/","link":"","permalink":"https://merlinahh.github.io/2018/06/13/Hexo-GitHub-to-built-a-blog-3/","excerpt":"","text":"您可以在 _config.yml 中修改大部分的配置。 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York， Japan， 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的永久链接格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为title case false external_link 在新标签中打开链接 true filename_case 把文件名称转换为(1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动Asset文件夹，影响图片引入 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 默认情况下，Hexo生成的超链接都是绝对地址。 例如，如果您的网站&gt; 域名为example.com，您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。 通常情况下，建议用绝对地址。 分类 &amp; 标签 参数 描述 默认值 default_category 默认分类 category_map 分类别名 tag_map 标签别名 日期时间格式Hexo 使用Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 扩展 参数 描述 默认值 theme 当前主题名称。值为false时禁用主题 deploy 部署部分的设置","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"GitHub Page","slug":"GitHub-Page","permalink":"https://merlinahh.github.io/tags/GitHub-Page/"},{"name":"HEXO","slug":"HEXO","permalink":"https://merlinahh.github.io/tags/HEXO/"}],"author":"Merlin"},{"title":"Hexo + GitHub Page 目录结构","slug":"Hexo-GitHub-to-built-a-blog-2","date":"2018-06-13T00:34:28.000Z","updated":"2024-02-28T00:43:21.965Z","comments":true,"path":"2018/06/13/Hexo-GitHub-to-built-a-blog-2/","link":"","permalink":"https://merlinahh.github.io/2018/06/13/Hexo-GitHub-to-built-a-blog-2/","excerpt":"","text":"接上一篇 安装完环境，配置托管服务器，编写博客之前，需要了解目录结构： 项目目录结构项目创建完成，指定文件夹的目录如下： . ├── .deploy # 需要部署的文件 ├── node_modules # Hexo插件 ├── public # 生成的静态网页文件 ├── scaffolds # 模板 ├── source # 博客正文和其他源文件等 | ├── _drafts # 草稿 | └── _posts # 文章 ├── themes # 主题 ├── _config.yml # 全局配置文件 └── package.json # npm 依赖等 package.jsonpackage.json 文件：应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 123456789101112131415161718192021222324252627&#123; &quot;name&quot;: &quot;hexo-site&quot;, # 项目名称 &quot;version&quot;: &quot;0.0.0&quot;, # 项目版本号 &quot;private&quot;: true, &quot;scripts&quot;: &#123; # npm 命令 &quot;build&quot;: &quot;hexo generate&quot;, &quot;clean&quot;: &quot;hexo clean&quot;, &quot;deploy&quot;: &quot;hexo deploy&quot;, &quot;server&quot;: &quot;hexo server&quot; # 运行项目 &#125;, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;5.4.1&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^5.0.0&quot;, &quot;hexo-deployer-git&quot;: &quot;^3.0.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;, &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;, &quot;hexo-generator-index&quot;: &quot;^2.0.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^1.0.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^4.0.0&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^2.0.0&quot;, &quot;hexo-server&quot;: &quot;^2.0.0&quot;, &quot;hexo-theme-landscape&quot;: &quot;^0.0.3&quot; &#125;&#125; scaffoldsscaffolds 模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 sourcesource 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themesthemes 主题文件夹。Hexo 会根据主题来生成静态页面。","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"GitHub Page","slug":"GitHub-Page","permalink":"https://merlinahh.github.io/tags/GitHub-Page/"},{"name":"HEXO","slug":"HEXO","permalink":"https://merlinahh.github.io/tags/HEXO/"}],"author":"Merlin"},{"title":"Hexo + Github 搭建博客","slug":"Hexo-Github-to-build-a-blog","date":"2018-06-12T21:16:12.000Z","updated":"2024-02-28T00:43:30.660Z","comments":true,"path":"2018/06/13/Hexo-Github-to-build-a-blog/","link":"","permalink":"https://merlinahh.github.io/2018/06/13/Hexo-Github-to-build-a-blog/","excerpt":"","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js (Should be at least nodejs 6.9) Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 1. 安装 Node.js由于 Hexo 博客系统是基于 Node.js 编写的，所以要安装 Node.js 。Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。 官网下载安装包： https://nodejs.org/en/ 安装过程不要修改配置，一路确认下一步 确认安装结束 打开终端输入 12node -vnpm -v 显示出版本号即安装成功 2. 安装 Git使用 git 将代码/文章提交到 GitHub 托管，不需要购买服务器和域名就能够实现博客的运行和访问。 打开终端输入 1git --version 显示出版本号即安装成功 Github账号注册：https://github.com/ 仓库创建： 仓库名一定是你的用户名（以下用 MerlinAhh 代替）， 例：MerlinAhh/MerlinAhh.github.io 访问 MerlinAhh.github.io，如果可以正常访问，那么 Github 的配置已经结束了。 到此搭建 Hexo 博客的相关环境配置已经完成。 安装 HEXO HEXO文档：https://hexo.io/zh-cn/ 打开终端输入 1npm install -g hexo-cli 运行结束后输入 1hexo -v 显示版本号等信息即安装成功 创建本地项目创建本地项目并安装依赖 12345hexo init MerlinAhh.github.iocd MerlinAhh.github.ionpm install 安装结束后可见项目结构 . ├── .deploy #需要部署的文件 ├── node_modules #Hexo插件 ├── public #生成的静态网页文件 ├── scaffolds #模板 ├── source #博客正文和其他源文件等 | ├── _drafts #草稿 | └── _posts #文章 ├── themes #主题 ├── _config.yml #全局配置文件 └── package.json #npm 依赖等 打开 package.json 可见 scripts 中为 npm 命令 执行 1npm server 即可，或者 1hexo server 或 hexo s 打开 http://localhost:4000/ 显示该界面，即说明你的hexo本地博客搭建成功。 本地项目关联 GitHub Page 项目本地项目根目录找到 _config.yml 文件最后一行，修改 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: git@github.com:MerlinAhh/MerlinAhh.github.io.git （自己的仓库地址） branch: master 删除旧的 public 文件 1hexo clean 打包新的 public 文件 123hexo generate或者hexo g 开始部署 123hexo deploye或者hexo d 部署结束后，浏览器中输入你的网址 MerlinAhh.github.io 查看 (此时可能有一两分钟延迟，耐心等下) 更换主题 官方主题：https://hexo.io/themes/ 下载主题到你的 theme 目录，项目根目录下 _config.yml 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: merlintheme theme 修改成新下载的主题目录名即可！ 总结HEXO + GitHub Pages 的优势是无需购置服务器，免服务器费的同时还能做负载均衡，并且 github pages有300M免费空间。只做个人文章展示，完全够用的！","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"GitHub Page","slug":"GitHub-Page","permalink":"https://merlinahh.github.io/tags/GitHub-Page/"},{"name":"HEXO","slug":"HEXO","permalink":"https://merlinahh.github.io/tags/HEXO/"}],"author":"Merlin"},{"title":"小程序_推送模板消息 TEMPLATE","slug":"wxapp-template","date":"2018-06-02T02:56:52.000Z","updated":"2024-02-28T00:45:09.279Z","comments":true,"path":"2018/06/02/wxapp-template/","link":"","permalink":"https://merlinahh.github.io/2018/06/02/wxapp-template/","excerpt":"","text":"模板消息 页面 123&lt;form bindsubmit=&quot;formSubmit&quot; report-submit=&quot;ture&quot;&gt; &lt;button formType=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; js逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445formSubmit: function (e) &#123; var that = this var formId = e.detail.formId var data = &#123; &quot;keyword1&quot;: &#123; &quot;value&quot;: &quot;339208499&quot;, &quot;color&quot;: &quot;#173177&quot; &#125;, &quot;keyword2&quot;: &#123; &quot;value&quot;: &quot;2015年01月05日 12:30&quot;, &quot;color&quot;: &quot;#173177&quot; &#125;, &quot;keyword3&quot;: &#123; &quot;value&quot;: &quot;粤海喜来登酒店&quot;, &quot;color&quot;: &quot;#173177&quot; &#125;, &quot;keyword4&quot;: &#123; &quot;value&quot;: &quot;广州市天河区天河路208号&quot;, &quot;color&quot;: &quot;#173177&quot; &#125; &#125; data = JSON.stringify(data) var params = new Object() params.templateId = &#x27;1MZ9eoaAEmOHR-5BO52ahVpDhLXu6ZGJ52NK_x6_Yxc&#x27;, params.page = &#x27;/pages/profile/comment&#x27;, params.formId = formId, params.data = data // 写入参数 params.productId = productId params.url = app.config.apiBase + &quot;/front/template/pushtemplate&quot; // 发起请求 network.POST(&#123; params: params, success: function (res) &#123; console.log(res) &#125;, fail: function (res) &#123; console.log(res) &#125; &#125;)&#125; 小程序模板消息 小程序可以多次存储 formid 进行多次推送消息，目前一些大一点的做小程序粉丝互动的平台基本上都是用这个方法。","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://merlinahh.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"author":"Merlin"},{"title":"三种方式实现瀑布流图文布局","slug":"Masonry-Layouts","date":"2018-02-16T16:49:26.000Z","updated":"2024-02-28T00:50:35.058Z","comments":true,"path":"2018/02/17/Masonry-Layouts/","link":"","permalink":"https://merlinahh.github.io/2018/02/17/Masonry-Layouts/","excerpt":"","text":"瀑布流又称瀑布流式布局，是比较流行的一种网站页面布局方式，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。 最早采用此布局的网站是Pinterest，逐渐在国内流行开来。 花瓣、小红书等需要图文混排，且图片尺寸不一的网站，布局都是使用的瀑布流。 瀑布流的优势： 不裁剪不拉伸的以原比例完整的展示图片，不同尺寸排布错落有致 空间使用更加充分，视觉上也让注意力集中在图片上，便于快速获得更多信息 布局简洁清新，避免页面复杂乱糟糟 以下介绍瀑布流在前端的三种实现方案 1. 纯 HTML + CSS column 实现column可以指定容器下元素列的宽度和数量 1columns: column-width column-count; 瀑布流用到的属性是： column-count：指定列数 column-gap：列之间的差距 演示： html： 12345678&lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;https://s4.ax1x.com/2022/02/17/H4YZeH.png&quot; /&gt; &lt;h3&gt;标题&lt;/h3&gt; &lt;p&gt;描述&lt;/p&gt; &lt;/div&gt; ...&lt;/div&gt; css: 1234567891011121314.list &#123; columns: 4; column-gap: 20px;&#125;.item &#123; width: auto; break-inside: avoid; margin-bottom: 20px;&#125;.item img &#123; width: 100%;&#125; 此方案布局排布顺序见图，从上至下，从左至右，布局顺序不太理想。但是不需要js，纯 HTML + CSS 实现的。 在线demo 2. 纯 HTML + CSS flex 实现对父容器设置弹性盒后，因为瀑布流是多行的所以还要flex-wrap设置wrap，并且flex-direction还要设置为column。 最关键的是一定要设置一个高度。 演示： html: 123456&lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;img&quot; style=&quot;height:100px&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;img&quot; style=&quot;height:250px&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;img&quot; style=&quot;height:120px&quot;&gt;3&lt;/div&gt; ...&lt;/div&gt; css: 123456789101112131415161718192021222324252627282930313233.list &#123; display: flex; flex-wrap: wrap; flex-direction: column; height: 3800px;&#125;.list&gt;.img &#123; position: relative; width: calc(100% / 4 - 20px); margin: 10px; box-sizing: border-box; background: rgb(193, 193, 193); font-size: 40px; text-align: center; color: rgb(229, 229, 229);&#125;.list&gt;.img:nth-child(4n+1) &#123; order: 1;&#125;.list&gt;.img:nth-child(4n+2) &#123; order: 2;&#125;.list&gt;.img:nth-child(4n+3) &#123; order: 3;&#125;.list&gt;.img:nth-child(4n) &#123; order: 4;&#125; 在线demo 3. js + position 实现js实现瀑布流的话，考虑把子元素全部设置成绝对定位。 然后监听图片加载，如果加载完就把子元素设置其对应的位置，逐个塞到父容器中。 父容器高度取列表数组的最大值，子元素设置 absolute 通过上一层排列位置及高度，来摆放下一个的 top/left 定位位置 演示： html: 1234&lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;img&quot;&gt;1&lt;/div&gt; ...&lt;/div&gt; css: 12345.list .img &#123; position: absolute; width: 250px; margin: 10px;&#125; js: 123456789101112131415161718192021222324252627282930313233343536373839404142var colCount // 定义列数var colHeightArry = [] // 定义列高度数组var imgWidth = $(&#x27;.list .img&#x27;).outerWidth(true) // 单张图片的宽度colCount = parseInt($(&#x27;.list&#x27;).width() / imgWidth) // 计算出列数for (var i = 0; i &lt; colCount; i++) &#123; colHeightArry[i] = 0&#125;// 当窗口大小重置之后，重新执行$(window).on(&#x27;resize&#x27;, function () &#123; reset()&#125;)// 当窗口加载完毕，执行瀑布流$(window).on(&#x27;load&#x27;, function () &#123; reset()&#125;)// 定义reset函数function reset() &#123; var colHeightArry = [] colCount = parseInt($(&#x27;.list&#x27;).width() / imgWidth) for (var i = 0; i &lt; colCount; i++) &#123; colHeightArry[i] = 0 &#125; $(&#x27;.list .img&#x27;).each(function () &#123; var minValue = colHeightArry[0] var minIndex = 0 for (var i = 0; i &lt; colCount; i++) &#123; if (colHeightArry[i] &lt; minValue) &#123; minValue = colHeightArry[i] minIndex = i &#125; &#125; $(this).css(&#123; height: Math.floor(Math.random() * (600 - 100 + 1)) + 100, left: minIndex * imgWidth, top: minValue &#125;) colHeightArry[minIndex] += $(this).outerHeight(true) &#125;)&#125; 在线demo 总结以上就是瀑布流布局的三种主流方案。 只使用 css 实现相对简单，性能好，图片自动填充不用考虑图片加载状态。column 的效果无法修改排布顺序，flex 实现的顺序在一定程度上可以改变。 使用 js 实现，优点是控制灵活，随意扩展，也可以无限加载，不用过多考虑兼容问题，同时可以添加诸多动画来增强用户体验。但是实现相对复杂。图片填充需要考虑图片加载状态，性能逊色于纯css实现。","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://merlinahh.github.io/tags/js/"},{"name":"笔记","slug":"笔记","permalink":"https://merlinahh.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://merlinahh.github.io/tags/HTML-CSS/"}],"author":"Merlin"},{"title":"表单验证工具函数集合","slug":"CheckUtil","date":"2018-02-10T08:03:25.000Z","updated":"2022-02-17T08:20:53.163Z","comments":true,"path":"2018/02/10/CheckUtil/","link":"","permalink":"https://merlinahh.github.io/2018/02/10/CheckUtil/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141export default class CheckUtil &#123; /** * 验证手机号 */ checkPhone(phoneNum: string) &#123; let phoneReg = /^1\\d&#123;10&#125;$/; if (phoneReg.test(phoneNum)) &#123; //手机号码格式正确 return true &#125; else &#123; //手机号码格式不正确 return false &#125; &#125; /** * 验证邮箱 */ checkEmail(email: string) &#123; let emailReg = /^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.[a-zA-Z0-9]&#123;2,6&#125;$/; if (emailReg.test(email)) &#123; //邮箱格式正确 return true; &#125; else &#123; //邮箱格式不正确 return false; &#125; &#125; /** * 验证QQ邮箱 */ checkQQ(qq: string) &#123; let qqReg = /^[1-9][0-9]&#123;4,9&#125;$/gim; if (qqReg.test(qq)) &#123; //邮箱格式正确 return true; &#125; else &#123; //邮箱格式不正确 return false; &#125; &#125; /** * 验证账号 */ checkAccount(email: string) &#123; let emailReg = /^[a-zA-Z0-9/!@#$%^&amp;*()-_+,.?/&lt;&gt;|]&#123;1,32&#125;$/; if (emailReg.test(email)) &#123; //邮箱格式正确 return true; &#125; else &#123; //邮箱格式不正确 return false; &#125; &#125; /** * 验证图形验证码 */ checkimgVerificatioCode(imgVerificatioCode: string) &#123; if (imgVerificatioCode.length == 4) &#123; //短信验证码正确 return true; &#125; else &#123; //短信验证码不正确 return false; &#125; &#125; /** * 验证短信验证码 */ checkSmscode(smscode: string) &#123; if (smscode.length == 6 || smscode.length == 5) &#123; //短信验证码正确 return true; &#125; else &#123; //短信验证码不正确 return false; &#125; &#125; /** * 验证邮箱验证码 */ checkMailcode(mailcode: string) &#123; if (mailcode.length == 6) &#123; //邮箱验证码格式正确 return true; &#125; else &#123; //邮箱验证码格式不正确 return false; &#125; &#125; /** * 验证被记住密码 */ checkRemberPwd(pwd: string) &#123; let pwdReg = /^[a-zA-Z0-9]&#123;32&#125;$/ if (pwdReg.test(pwd)) &#123; //密码格式正确 return true; &#125; else &#123; //密码格式不正确 return false; &#125; &#125; /** * 验证密码 */ checkPwd(pwd: string) &#123; let pwdReg = /^(?![0-9]+$)(?![a-zA-Z]+$)(?![!@#$%^&amp;*()_+,.?/&lt;&gt;|]+$)[0-9A-Za-z!@#$%^&amp;*()_+,.?/&lt;&gt;|]&#123;6,20&#125;$/ if (pwdReg.test(pwd)) &#123; //密码格式正确 return true; &#125; else &#123; //密码格式不正确 return false; &#125; &#125; /** * 验证二级密码 */ checkSecondPwd(pwd: string) &#123; let pwdReg = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;4,12&#125;$/ if (pwdReg.test(pwd)) &#123; //密码格式正确 return true; &#125; else &#123; //密码格式不正确 return false; &#125; &#125; /** * 确认密码验证 */ checkPwdTwo(pwdTwo: string, pwd: string) &#123; if (pwdTwo == pwd) &#123; //密码格式正确 return true; &#125; else &#123; //密码格式不正确 return false; &#125; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://merlinahh.github.io/tags/js/"},{"name":"笔记","slug":"笔记","permalink":"https://merlinahh.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Merlin"},{"title":"RegExp 正则匹配去空格处理","slug":"RegExp-remove-space","date":"2017-12-11T02:53:04.000Z","updated":"2024-02-28T00:44:12.634Z","comments":true,"path":"2017/12/11/RegExp-remove-space/","link":"","permalink":"https://merlinahh.github.io/2017/12/11/RegExp-remove-space/","excerpt":"","text":"去首尾空白字符 123456789101112131415var Message = &#x27;&#x27;var trim = function trim(str) &#123;//将空格替换为无str = str.replace(/^(\\s|\\u00A0)+/, &#x27;&#x27;);for (var i = str.length - 1; i &gt;= 0; i--) &#123; if (/\\S/.test(str.charAt(i))) &#123; str = str.substring(0, i + 1); break; &#125;&#125;console.log(str)Message = strreturn str;&#125; 调用方法： 12345678910111213141516171819202122232425262728//写trim方法function trim(str)&#123; // 将空格替换为无 str=str.replace(/^(\\s|\\u00A0)+/,&#x27;&#x27;); // 此处设置空格替换内容 for(var i=str.length-1; i&gt;=0; i--)&#123; if(/\\S/.test(str.charAt(i)))&#123; str = str.substring(0,i+1); break; &#125; &#125; return str;&#125;//调用function commithandling()&#123; var suggestion=document.getElementById(&quot;suggestion&quot;).value; if(trim(suggestion)!=&quot;&quot;&amp;&amp; suggestion.length&gt;0)&#123; $.post(&quot;/lord/commithandling&quot;,&#123;&#x27;idea&#x27;:suggestion&#125;,function(data)&#123; if(data==1)&#123; alert(&quot;提交意见成功&quot;); document.location.reload(); &#125;else&#123; alert(&quot;处理意见不能为空&quot;); &#125; &#125; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"RegExp","slug":"RegExp","permalink":"https://merlinahh.github.io/tags/RegExp/"}],"author":"Merlin"},{"title":"小程序实现我的足迹","slug":"wxapp-StorageSync","date":"2017-12-08T02:50:03.000Z","updated":"2024-02-28T00:46:43.124Z","comments":true,"path":"2017/12/08/wxapp-StorageSync/","link":"","permalink":"https://merlinahh.github.io/2017/12/08/wxapp-StorageSync/","excerpt":"","text":"关于历史搜索 12345678910111213&lt;input type=&quot;text&quot; class=&quot;search-icon&quot; placeholder=&quot;请输入要搜索的内容&quot; bindinput=&quot;searchNameInput&quot;/&gt;&lt;text bindtap=&quot;setSearchStorage&quot;&gt;搜索&lt;/text&gt;&lt;view&gt; &lt;view&gt; &lt;text style=&quot;float:left;&quot; bindtap=&quot;deleteHistory&quot;&gt;历史搜索&lt;/text&gt; &lt;text style=&quot;float:right;&quot; bindtap=&quot;deleteHistory&quot;&gt;删除搜索历史&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;view class=&quot;search-list&quot; wx:for=&quot;&#123;&#123;searchData&#125;&#125;&quot; wx:key=&quot;item&quot;&gt; &lt;view&gt;&#123;&#123;item == null?&#x27;暂无数据&#x27;:item&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 这里有三个绑定事件 12345bindinput=”searchNameInput” 获取用户输入的数据bindtap=”setSearchStorage” 设置本地存储bindtap=”deleteHistory” 删除历史搜索 12345678910111213141516171819202122232425262728293031323334// 获取用户输入框的值searchNameInput:function(e)&#123; var that = this; that.setData(&#123; inputValue:e.detail.value &#125;)&#125;// e.detail.value 即当前输入值当点击搜索的时候，bindtap=”setSearchStorage”// 将用户输入的内容存入本地缓存,并且将搜索数据放到首页setSearchStorage:function()&#123; var that = this if(this.data.inputValue != &#x27;&#x27;)&#123; // 调用API向本地缓存存入数据 var searchData = wx.getStorageSync(&#x27;searchData&#x27;) || [] searchData.push(this.data.inputValue) wx.setStorageSync(&#x27;searchData&#x27;, searchData) // 读取用户搜索商品 var name = this.data.inputValue wx.request(&#123; url: &#x27;www.shop.com/home/product/search&#x27;, data: &#123;name:name&#125;, method: &#x27;GET&#x27;, success: function(res)&#123; that.setData(&#123; goodsList: res.data.info, &#125;) &#125;, &#125;) &#125;&#125; 流程这么走： 1.用户输入数据，点击搜索 2.如果数据不为空，加入（设置）本地缓存 3.去服务器搜索用户想要的数据，赋值给这个页面的变量 4.点击删除，去除本地这个key的value 这里的缓存形式的 key=&gt;value var searchData = wx.getStorageSync(‘searchData’) || [] 获取本地名字为’searchData’的缓存，如果’searchData’这个缓存不存在就相当于重新什么一个空数组，赋值给searchData这个变量 searchData.push(this.data.inputValue) 将用户输入的值PUSH进searchData这个变量里 wx.setStorageSync(‘searchData’, searchData) 调用API接口，重新设置key = ‘searchData’的这个缓存的value等于searchData 下面的wx.request是请求数据的内容，说腻了，印象够深了。 这里没有绑定获取缓存的bindtap，只要获取到，然后添加到Page里面的data 这里是将’searchData’这个key的缓存的value为空数组，而不是使用API提供的wx.clearStorageSync，这个会清除其他的所有缓存，而我只是想清除这一个key的缓存","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://merlinahh.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"author":"Merlin"},{"title":"加减乘除法函数","slug":"subtracting","date":"2017-12-06T02:43:08.000Z","updated":"2024-02-28T00:44:25.947Z","comments":true,"path":"2017/12/06/subtracting/","link":"","permalink":"https://merlinahh.github.io/2017/12/06/subtracting/","excerpt":"","text":"封装好的加减乘除法函数, 用于解决 js number 类型 + - * / 运算时丢失精度问题 在javascript中，当你使用小数进行加减乘除运算时，你会发现，所得到的结果有时后面带有长长的一段小数，使运算变得复杂，并且影响计算结果。上网查询了一下原因，大致如下：在javascript中，带小数的数据运算时总会出现好多位小数.这是因为在javascript中浮点数的计算是以2进制计算的。 加法函数 避免数据相加小数点后产生多位数和计算精度损失。 123456789101112131415161718192021function accAdd(arg1, arg2) &#123; var r1, r2, m; try &#123; r1 = arg1.toString().split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; r2 = 0; &#125; m = Math.pow(10, Math.max(r1, r2)); return (arg1 * m + arg2 * m) / m;&#125; //给Number类型增加一个add方法，，使用时直接用 .add 即可完成计算。Number.prototype.add = function (arg) &#123; return accAdd(arg, this);&#125;; 减法函数 避免数据相减小数点后产生多位数和计算精度损失。 12345678910111213141516171819202122232425function Subtr(arg1, arg2) &#123; var r1, r2, m, n; try &#123; r1 = arg1.toString().split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; r2 = 0; &#125; m = Math.pow(10, Math.max(r1, r2)); //last modify by deeka //动态控制精度长度 n = (r1 &gt;= r2) ? r1 : r2; return ((arg1 * m - arg2 * m) / m).toFixed(n);&#125;//给Number类型增加一个add方法，，使用时直接用 .sub 即可完成计算。Number.prototype.sub = function (arg) &#123; return Subtr(this, arg);&#125;; 乘法函数 避免数据相乘小数点后产生多位数和计算精度损失。 12345678910111213141516171819function accMul(arg1, arg2) &#123; var m = 0, s1 = arg1.toString(), s2 = arg2.toString(); try &#123; m += s1.split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; &#125; try &#123; m += s2.split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; &#125; return Number(s1.replace(&quot;.&quot;, &quot;&quot;)) * Number(s2.replace(&quot;.&quot;, &quot;&quot;)) / Math.pow(10, m);&#125; //给Number类型增加一个mul方法，使用时直接用 .mul 即可完成计算。Number.prototype.mul = function (arg) &#123; return accMul(arg, this);&#125;; 除法函数 避免数据相除小数点后产生多位数和计算精度损失。 1234567891011121314151617181920212223function accDiv(arg1, arg2) &#123; var t1 = 0, t2 = 0, r1, r2; try &#123; t1 = arg1.toString().split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; &#125; try &#123; t2 = arg2.toString().split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; &#125; with (Math) &#123; r1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;)); r2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;)); return (r1 / r2) * pow(10, t2 - t1); &#125;&#125;//给Number类型增加一个div方法，，使用时直接用 .div 即可完成计算。Number.prototype.div = function (arg) &#123; return accDiv(this, arg);&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://merlinahh.github.io/tags/js/"},{"name":"笔记","slug":"笔记","permalink":"https://merlinahh.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Merlin"},{"title":"常用17个正则表达式整理","slug":"Commonly-used-17-reg","date":"2017-12-05T02:26:33.000Z","updated":"2024-02-28T00:42:33.117Z","comments":true,"path":"2017/12/05/Commonly-used-17-reg/","link":"","permalink":"https://merlinahh.github.io/2017/12/05/Commonly-used-17-reg/","excerpt":"","text":"正则表达式regular expression一个有规则的表达式简单的说 他就是一个用于 查找的通配符 1234bookbokbouk… b*k 或 b?k 将以 b 开头, 以 k 结尾的单词 全部列出来正则表达式就是 一个用于查找的 含有 匹配字符串 或 匹配元字符的 字符串 1234“123”“abc”“\\d” 一个数字( 0 ~ 9 ) 正则表达式对象js 正则表达式对象 就是 由 正则表达式创建的对象, 该对象可以进行 匹配, 提取 和 替换. 创建正则表达式对象 构造函数var regex = new RegExp( 正则表达式字符串[, 匹配模式] ); 字面量var regex = /正则表达式/; 使用正则表达式进行匹配语法: 正则对象.test( 字符串 ) -&gt; bool如果参数字符串中含有 复合 正则匹配的 子字符串, 就返回 true, 否则返回 false 例如: 查询一段文字中是否包含 itcast 基本元字符. 表示任一个非换行的字符案例: foot _ 是 food, foot 写成 foo. () 表示分组和提高优先级[] 表示一个字符, 出现在 [] 中的字符用法: [abc] 出现 [] 中的任意一个字符匹配 a, 或 b, 或 c 1foo[dt] | 或用法: 正则表达式|正则表达式 123foot 或 foodfoot|foodfoo(t|d) 扩展:. 任意的一个字符. 没有任何限制[] 是出现在[]中的一个字符. 认为 . 的限制级版本[abc]: a 或者 b 或者 c| 可以认为是 允许使用多个字符的 匹配 12a|b|caa|bb|cc 转义字符: 表示点: .表示[]: [ ]表示(): ( )表示\\ : \\ 限定元字符紧跟前面的一个字符或一组字符出现 0 次到多次表示: 123333333 后面很多 3正则: 1233123 0 次1233 1 次12333 2 次…1233333333333333333 1(23)*表示: 1 0 次 123 1 次 12323 2 次 1232323 3 次 + 紧跟在前面的字符出现 1 次到多次字符串: 123333333正则: 123+123123312333 ? 紧跟在前面的字符出现 0 次或 1 次在一段字符串中检查是否含有 http 协议的字符串或 https 协议的字符串http://.+|https://.+https?://.+ {数字} 紧跟在前面的字符出现指定次数1a&#123;3&#125; aaa {数字,} 紧跟在前面的字符至少出现指定次数1a&#123;3,&#125; aaa, aaaaaaaaa, aaaaaaaaaaaaaa, … {数字, 数字} 紧跟在前面的字符出现的次数范围1a&#123;1, 3&#125; a, aa, aaa 首尾正则表达式^ 表示必须以 xxx 开头^a 必须以 a 开头的字符串a 表示一个字符串中只要含有 a 就可以匹配 ^a^a 非法的写法, ^ 如果是表示开头必须写在开头, 而且只能写一个表示必须以xxx结尾a 必须以 a 结尾 分析 ^a+$ 案例写一个正则表达式匹配 身份证号码身份证是 18 位数字省 市 区 出生年月 随机编码X 首先是要做匹配, 就一定要使用 ^ $ 是 18 位数字( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ). 可以使用 [0123456789]还可以使用 0|1|2|3|4|5|6|7|8|9 要求是 18 位. 限定 18 位, 即 {18} 组合: ^[0123456789]{18}$ 如果最后一位是x前面 17 位数字: ^[0123456789]{17}$后面要么是数字: [0123456789]要么是 x: x写法: [0123456789x] [0123456789]|x 0|1|2|3|4|5|6|7|8|9|x ^[0123456789]{17}[0123456789x]$ 匹配邮箱&#49;&#50;&#x33;&#52;&#53;&#x36;&#x37;&#x38;&#57;&#48;&#x31;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#109;&#97;&#98;&#99;&#x64;&#x65;&#102;&#x67;&#x40;&#49;&#x32;&#x36;&#x2e;&#x63;&#111;&#x6d;&#x61;&#98;&#99;&#100;&#x65;&#x66;&#x67;&#64;&#49;&#54;&#51;&#x2e;&#99;&#111;&#109;&#97;&#98;&#x63;&#64;&#x79;&#97;&#x68;&#x6f;&#111;&#x2e;&#x63;&#x6f;&#x6d;&#x2e;&#x63;&#110;.cc.org.edu.中文… 名字 @ 主机名 是要验证邮箱, 那么就需要使用 ^ $ 名字: 数字与字母 [0123456789] [abcdefghi…] [ABCDEFG…] [] 里面的字符如果是编码序号连续的可以使用连字符连接 数字: [0-9] [9-0] 错误的, 编码逆序 字母: [a-z] [A-Z] 整合: [0-9a-zA-Z] 名字的变式方法: [0-9a-zA-Z]+ 主机名 主机名也是一串字符串或数字 但是它多了一个 .com .cn 3.1) 只有名字 [0-9a-zA-Z]+ 3.2) 只含有一个 .什么 开始 . 中间 [0-9a-zA-Z]+ 只含有一个名字: .[0-9a-zA-Z]+ 3.3) 含有多个名字 .com.con.cc.c1.c2.c3 即 .什么 出现一次到多次 1(\\.[0-9a-zA-Z]+)+ 最后主机名可以写成 1[0-9a-zA-Z]+(\\.[0-9a-zA-Z]+)+ 最后整合一下 1^[0-9a-zA-Z]+@[0-9a-zA-Z]+(.[0-9a-zA-Z]+)+$ 匹配一个数字匹配一个数字[0-9]+ 由于是匹配, 包含 ^ 2)首先第一个字符不允许是0,所以第一个可以写成[1−9]3)后面的数字就是[0−9]4)要求后面的数字出现0次到多次,以匹配任意的非0数字:[1−9][0−9]5)由于还需要考虑0,因此写成[1−9][0−9]|06)考虑|优先级最低:([1−9][0−9]∗|0)^(-?[1-9][0-9]*|0)$2&gt; 匹配一个指定范围的数字匹配 0 ~ 255 为例[0-255] 0, 1, 2, 5 错误的 如果要匹配指定范围的数字, 那么需要将字符串结构进行分类 0 要匹配的, 所以在正则表达式中有 0 这一项 任意的 2 位数, 即 [1-9][0-9] 任意的 1 位数, 即 [0-9], 可以将 第 1) 结论合并 考虑 3 位数的时候, 只允许出现 1xx 的任意数, 而 2xx 的有限制 因此在分组, 考虑 1xx 的任意数, 可以写成: 1[0-9][0-9] 考虑 2xx 的数字, 在 200 到 250 之间允许任意取. 所以 写成: 2[0-4][0-9] 考虑 250 到 255, 写成 25[0-5]1234567综合一起: ^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$匹配赢 IPv4 127.0.0.1 192.168.1.1^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))$ 匹配小数要求, 小数不允许以 0 结尾123456783.1415[0-9]*[1-9]^((-?[1-9][0-9]*|0)(\\.[0-9]*[1-9])?)$(aaa)? 这个内容出现或不出现(aaa|) 也是表达aaa可出现可不出现^((-?[1-9][0-9]*|0)(\\.[0-9]*[1-9]|))$ jq 中有一属性过滤选择器1[value=name] [value] [value !=name] ... 了解1\\[[a-zA-Z]((!|\\||~|^|$|)=...|)\\] 简写元字符12\\s 空白字符, 包括空格, tab, 回车换行等\\S 非空白字符 js 中常常使用 [\\s\\S] 表示任意字符12345\\w 表示字符, 包含字母, 数字, 下划线.\\W 非字符\\d 数字\\D 非数字 提取使用正则表达式可以进行匹配, 使用 exec 可以将匹配到的数据提取出来 语法: 1正则表达式对象.exec( 字符串 ) -&gt; 封装成数组 案例： 在 ‘abc123def456ghij789klum’ 提取数字 循环提取在一个字符串中将所有复合的要求的字符串提取出来 正则表达式需要使用全局模式12var r = new RegExp( ‘正则’, ‘g’ );var r = /正则/g; 调用 exec 首先获得第一个匹配项再调用一次该方法, 就可以获得 第二个匹配项一直调用下去, 就可以得到所有的匹配项直到最后全部匹配完, 如果还用该方法, 则返回 null 案例： 在 ‘abc123def456ghij789klum’ 提取数字 12345678910var r = /\\d+/g;r.exec( str ) =&gt; 123r.exec( str ) =&gt; 456r.exec( str ) =&gt; 789r.exec( str ) =&gt; nullwhile ( res = r.exec( str ) ) &#123;// 操作 res, 处理捕获的结果&#125; 将匹配到的结果进行解析假如有一个字符串: &#105;&#116;&#99;&#x61;&#x73;&#x74;&#x40;&#x69;&#x74;&#99;&#x61;&#x73;&#116;&#46;&#x63;&#x6e; 匹配提取邮箱, 同时将邮箱地址部分的名字和主机名都提取出来 案例:var str = ‘我有一个邮箱, 是 &#x69;&#116;&#99;&#97;&#x73;&#116;&#64;&#105;&#116;&#x63;&#97;&#x73;&#x74;&#46;&#x63;&#x6e;, 还有 &#x61;&#x62;&#99;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#111;&#109;, 和 &#49;&#50;&#51;&#52;&#53;&#x36;&#x37;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#x6d;‘要求将里面的邮箱全部提取出来, 然后将名字还有主机名也取出来 123456789// 循环提取的正则表达式var r = /[a-zA-Z\\d]+@[a-zA-Z\\d]+(.[a-zA-Z\\d]+)+/g;// 如果需要将匹配到的结果再次分解, 可以使用分组的形式, 在正则中分组即可var r = /([a-zA-Z\\d]+)@([a-zA-Z\\d]+(.[a-zA-Z\\d]+)+)/g;// 注意, 正则表达式中, 分组是有编号的. 从左往右数 ‘(‘. 从 1 开始依次编号// 匹配提取的结果中, 对应的编号就可以获得分解的数据 匹配但是不去捕获的元字符1(?:其他正则表达式内容) 要截取一个字符串中的一个 html 标签var str = ‘1234567890’; 要截取 html 标签, 标签使用 &lt;&gt;. 因此正则表达式写成 &lt;\\w+&gt;与之匹配的标签名是什么?如果在一个正则表达式中使用组匹配到某一个数据, 允许在该正则表达式中使用‘\\数字’ 的方式引用该组 1&lt;(\\w+)&gt;.*&lt;\\/\\1&gt; 贪婪模式凡是在正则表达式中, 涉及到次数限定的, 一般默认都是尽可能的多匹配. 取消贪婪模式. 在次数限定符后面加上 ? 注意: 贪婪模式性能会略高于非贪婪模式, 所以开发的时候. 一般不考虑贪婪的问题只有代码匹配结果出现问题了, 一般一次多匹配了, 才会取消贪婪 多个贪婪在一起的时候的强度 123\\d+\\d+\\d+1234567 如果取消贪婪模式 1\\d+?\\d+\\d+ 否定元字符语法:[^字符]不为这些字符的字符 [^abc] 不是 a 也不是 b 也不是 c 的字符 字符串的替换语法: 1字符串.replace( 查找字符串, 替换字符串 ) -&gt; 字符串 字符串替换方法1字符串1.replace( 字符串2, 字符串3 ) 在 字符串1 中找到 字符串2, 将其替换成 字符串3, 返回替换后的字符串特点: 只替换第一个找到的字符串 1&quot;aaa&quot;.replace( &#x27;a&#x27;, &#x27;A&#x27; ) -&gt; &#x27;Aaa&#x27; 正则替换1字符串.replace( 正则表达式, 字符串 ) -&gt; 字符串 简单替换12&#x27;aaaaa-------bbbbbb------ccccc&#x27;.replace( /-+/, &#x27;-&#x27; )&#x27;aaaaa-------bbbbbb------ccccc&#x27;.replace( /-+/g, &#x27;-&#x27; ) 分组替换 可以在替换字符串中, 使用 $数字 来引用替换的数据12345678&#x27;abc123&#x27;.replace( /(\\d+)/, &#x27;d$1&#x27; ) -&gt; &#x27;abcd123&#x27;&#x27;1991-1-1&#x27;中国: 1991年1月1日欧洲: 1/1/1991... : 1991 1 1&#x27;1991-1-19&#x27;.replace( /(\\d+)-(\\d+)-(\\d+)/, &#x27;$1年$2月$3日&#x27; ) 函数参数用法(了解)语法:字符串.replace( 正则表达式, fn )12345678910111213141516171819202122&#x27;我的邮箱是:abc@itcast.cn, 你的邮箱是: defghijk@itcast.cn&#x27; .replace( /\\w+@\\w+(\\.\\w+)+/g, &#x27;*&#x27; );&#x27;我的邮箱是:abc@itcast.cn, 你的邮箱是: def@itcast.cn&#x27; .replace( /(\\w+)@(\\w+(\\.\\w+)+)/g, function ( s, g1, g2, g3 ) &#123; return &#x27;*&#x27;; &#125; );// 要求 只显示 第一个字符, 其余的都是用 * 表示&#x27;我的邮箱是:abc@itcast.cn, 你的邮箱是: defghijklim@itcast.cn&#x27; .replace( /(\\w+)@(\\w+(\\.\\w+)+)/g, function ( s, g1, g2, g3 ) &#123; // 将用户名 变成 a***** 的形式 var first = g1.charAt( 0 ); var start = []; for ( var i = 0; i &lt; g1.length - 1; i++ ) &#123; start.push( &#x27;*&#x27; ); &#125; return first + start.join(&#x27;&#x27;) + &#x27;@&#x27; + g2; &#125; );","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"RegExp","slug":"RegExp","permalink":"https://merlinahh.github.io/tags/RegExp/"}],"author":"Merlin"},{"title":"小程序_微信重力感应 —— 摇一摇","slug":"wxapp-shake","date":"2017-11-09T02:22:14.000Z","updated":"2024-02-28T00:46:49.737Z","comments":true,"path":"2017/11/09/wxapp-shake/","link":"","permalink":"https://merlinahh.github.io/2017/11/09/wxapp-shake/","excerpt":"","text":"使用该功能的页面引用下面这段代码 12345678910111213141516171819202122232425262728// .jsPage(&#123; isShow: false, onShow: function () &#123; // 页面打开 var that = this; this.isShow = true; wx.onAccelerometerChange(function (e) &#123; // 微信重力 if(!that.isShow)&#123; return &#125; console.log(e.x) console.log(e.y) console.log(e.z) if (e.x &gt; 1 &amp;&amp; e.y &gt; 1) &#123; wx.showToast(&#123; title: &#x27;摇一摇成功&#x27;, icon: &#x27;success&#x27;, duration: 2000 &#125;) &#125; &#125;) &#125;, onHide: function()&#123; // 页面关闭 this.isShow = false; &#125;&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://merlinahh.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"author":"Merlin"},{"title":"小程序_操作图片(上传预览及保存)","slug":"wxapp-img-upload-and-download","date":"2017-11-08T11:14:12.000Z","updated":"2022-02-17T02:19:23.288Z","comments":true,"path":"2017/11/08/wxapp-img-upload-and-download/","link":"","permalink":"https://merlinahh.github.io/2017/11/08/wxapp-img-upload-and-download/","excerpt":"","text":"图片长按保存 图片长按保存(多张图片循环渲染后预览、保存、识别带参数二维码) 1234// .wxml&lt;view wx:for=&quot;&#123;&#123;imgalist&#125;&#125;&quot; wx:for-item=&quot;image&quot; class=&quot;previewimg&quot;&gt; &lt;image src=&quot;&#123;&#123;image&#125;&#125;&quot; data-src=&quot;&#123;&#123;image&#125;&#125;&quot; bindtap=&quot;previewImage&quot;&gt;&lt;/image&gt; &lt;/view&gt; 123456789101112// .jsPage(&#123; data: &#123; imgalist: [&#x27;http://sz800800.cn/video/test.png&#x27;, &#x27;http://sz800800.cn/video/test.png&#x27;], &#125;, previewImage: function (e) &#123; wx.previewImage(&#123; current: this.data.imgalist, // 当前显示图片的http链接 urls: this.data.imgalist // 需要预览的图片http链接列表 &#125;) &#125;,&#125;) 实现图片点开长按保存到相册 单张图片预览、保存、识别带参数二维码(目前实测无效果) 12345&lt;!-- .wxml--&gt; &lt;text class=&#x27;search_no&#x27;&gt;点击可保存及分享二维码&lt;/text&gt; &lt;view class=&#x27;view_img&#x27; &gt; &lt;image class=&#x27;img&#x27; bindtap=&quot;previewImage&quot; src=&#x27;&#123;&#123;scene&#125;&#125;&#x27;&gt;&lt;/image&gt;&lt;/view&gt; 1234567891011121314151617181920// .js var app = getApp(); Page(&#123; data: &#123; scene: &#x27;&#x27; &#125;, onLoad: function (options) &#123; var that = this var scene_img = &#x27;&#x27; //这里添加图片的地址 that.setData(&#123; scene: scene_img &#125;) &#125;, previewImage: function (e) &#123; wx.previewImage(&#123; urls: this.data.scene.split(&#x27;,&#x27;) // 需要预览的图片http链接 使用split把字符串转数组。不然会报错 &#125;) &#125; &#125;)","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://merlinahh.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"author":"Merlin"},{"title":"小程序_ACTIONSHEET 底部上划弹出的几种设置方法","slug":"wxapp-actionsheet","date":"2017-11-07T02:09:29.000Z","updated":"2024-02-28T00:44:40.925Z","comments":true,"path":"2017/11/07/wxapp-actionsheet/","link":"","permalink":"https://merlinahh.github.io/2017/11/07/wxapp-actionsheet/","excerpt":"","text":"小程序内置 ActionSheet 组件12345678wx.showActionSheet(&#123; itemList: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;], // 弹窗列表 success: function (res) &#123; // 确认后的操作 console.log(res.tapIndex) &#125;,fail: function (res) &#123; // 取消后的操作 console.log(res.errMsg) &#125; &#125;) 自定义 ActionSheet12345678// .wxml&lt;button type=&quot;default&quot; bindtap=&quot;actionSheetTap&quot;&gt;弹出action sheet&lt;/button&gt;&lt;action-sheet hidden=&quot;&#123;&#123;actionSheetHidden&#125;&#125;&quot; bindchange=&quot;actionSheetChange&quot;&gt; &lt;block wx:for-items=&quot;&#123;&#123;actionSheetItems&#125;&#125;&quot;&gt; &lt;action-sheet-item bindtap=&quot;bind&#123;&#123;item&#125;&#125;&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/action-sheet-item&gt; &lt;/block&gt; &lt;action-sheet-cancel &gt;取消&lt;/action-sheet-cancel&gt;&lt;/action-sheet&gt; 123456789101112131415161718192021222324252627282930// .jsvar items = [&#x27;item1&#x27;, &#x27;item2&#x27;, &#x27;item3&#x27;, &#x27;item4&#x27;]var pageObject = &#123; data: &#123; actionSheetHidden: true, actionSheetItems: items &#125;, actionSheetTap: function (e) &#123; console.log(this); this.setData(&#123; actionSheetHidden: !this.data.actionSheetHidden &#125;) &#125;, actionSheetChange: function (e) &#123; //点击ation-sheet-cancel，会触发action-sheet绑定的事件。在这里可以通过改变hidden控制菜单的隐藏 this.setData(&#123; actionSheetHidden: !this.data.actionSheetHidden &#125;); console.log(&quot;隐藏&quot;); &#125;&#125;for (var i = 0; i &lt; items.length; ++i) &#123; (function (itemName) &#123; pageObject[&#x27;bind&#x27; + itemName] = function (e) &#123; console.log(&#x27;click&#x27; + itemName, e) &#125; &#125;)(items[i])&#125;Page(pageObject)","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://merlinahh.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"author":"Merlin"},{"title":"小程序_微信支付功能","slug":"wxapp-payment","date":"2017-11-06T01:58:03.000Z","updated":"2024-02-28T00:46:55.563Z","comments":true,"path":"2017/11/06/wxapp-payment/","link":"","permalink":"https://merlinahh.github.io/2017/11/06/wxapp-payment/","excerpt":"","text":"主要逻辑层123456789101112131415161718192021222324252627282930// app.jsApp(&#123; onLaunch: function () &#123; //调用API从本地缓存中获取数据 var logs = wx.getStorageSync(&#x27;logs&#x27;) || [] logs.unshift(Date.now()) wx.setStorageSync(&#x27;logs&#x27;, logs) &#125;, getUserInfo:function(cb)&#123; var that = this if(this.globalData.userInfo)&#123; typeof cb == &quot;function&quot; &amp;&amp; cb(this.globalData.userInfo) &#125;else&#123; //调用登录接口 wx.login(&#123; success: function () &#123; wx.getUserInfo(&#123; success: function (res) &#123; that.globalData.userInfo = res.userInfo typeof cb == &quot;function&quot; &amp;&amp; cb(that.globalData.userInfo) &#125; &#125;) &#125; &#125;) &#125; &#125;, globalData:&#123; userInfo:null &#125;&#125;) 视图层1234&lt;!-- pay.wxml --&gt;&lt;view class=&quot;container&quot;&gt; &lt;button bindtap=&quot;payoff&quot;&gt;支付按钮&lt;/button&gt;&lt;/view&gt; 逻辑层12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// pay.js// 获取应用实例var app = getApp()Page(&#123; data: &#123; motto: &#x27;Hello World&#x27;, userInfo: &#123;&#125; &#125;, onLoad: function () &#123; console.log(&#x27;onLoad&#x27;) &#125;, // 点击按钮触发事件函数 payoff: function(e)&#123; var that = this; wx.login(&#123; success: function(res) &#123; that.getOpenId(res.code); &#125; &#125;); &#125;, // 获取openid getOpenId: function(code)&#123; var that = this; wx.request(&#123; url: &#x27;&#x27;, // getopenid method: &#x27;POST&#x27;, header: &#123; &#x27;content-type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;, data: &#123;&#x27;code&#x27;:code&#125;, success: function(res) &#123; var openId = res.data.openid; that.xiadan(openId); &#125; &#125;) &#125;, // 下单 xiadan: function(openId)&#123; var that = this; wx.request(&#123; url: &#x27;&#x27;, // xiadan method: &#x27;POST&#x27;, header: &#123; &#x27;content-type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;, data: &#123;&#x27;openid&#x27;:openId&#125;, success: function(res) &#123; var prepay_id = res.data.prepay_id; console.log(&quot;统一下单返回 prepay_id:&quot;+prepay_id); that.sign(prepay_id); &#125; &#125;) &#125;, // 签名 sign: function(prepay_id)&#123; var that = this; wx.request(&#123; url: &#x27;&#x27;, method: &#x27;POST&#x27;, header: &#123; &#x27;content-type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;, data: &#123;&#x27;repay_id&#x27;:prepay_id&#125;, success: function(res) &#123; that.requestPayment(res.data); &#125; &#125;) &#125;, // 申请支付 requestPayment: function(obj)&#123; wx.requestPayment(&#123; &#x27;timeStamp&#x27;: obj.timeStamp, &#x27;nonceStr&#x27;: obj.nonceStr, &#x27;package&#x27;: obj.package, &#x27;signType&#x27;: obj.signType, &#x27;paySign&#x27;: obj.paySign, &#x27;success&#x27;:function(res)&#123; &#125;, &#x27;fail&#x27;:function(res)&#123; &#125; &#125;) &#125; &#125;) 微信支付前端逻辑不复杂，主要和后端配合获取支付请求参数，里面也是有比较多的坑的~","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://merlinahh.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"author":"Merlin"},{"title":"小程序_MODAL 模态框弹出提示的几种设置方法","slug":"wxapp-modal-show","date":"2017-11-04T12:51:26.000Z","updated":"2024-02-28T00:47:02.802Z","comments":true,"path":"2017/11/04/wxapp-modal-show/","link":"","permalink":"https://merlinahh.github.io/2017/11/04/wxapp-modal-show/","excerpt":"","text":"小程序内置 Modal 组件1234567891011wx.showModal(&#123; title: &#x27;提示&#x27;, // 定义弹窗标题 content: &#x27;模态弹窗&#x27;, // 定义弹窗内容文本 success: function (res) &#123; if (res.confirm) &#123; console.log(&#x27;用户点击确定&#x27;) // 定义弹窗确认按钮 &#125;else&#123; console.log(&#x27;用户点击取消&#x27;) // 定义弹窗取消按钮 &#125; &#125; &#125;) 自定义 Modal Modal 自定义cover-view 用于嵌套在 map/canvas 组件中 123456789101112131415&lt;!-- &lt;map/canvas&gt; --&gt;&lt;cover-view class=&quot;modal&quot; wx:if=&#x27;&#123;&#123;!modalFlag&#125;&#125;&#x27;&gt; &lt;!-- &lt;cover-view class=&quot;modal&quot; hidden=&quot;&#123;&#123;modalFlag&#125;&#125;&quot;&gt; bug 非块级元素使用hidden不生效 使用 wx:if 可替代 注意: wx:if 与 hidden 判断相反 --&gt; &lt;cover-view class=&quot;dew&quot; wx:for=&quot;&#123;&#123;agentList&#125;&#125;&quot; wx:for-item=&quot;seller&quot; wx:if=&quot;&#123;&#123;index &lt; 1&#125;&#125;&quot; wx:key=&quot;seller.name&quot;&gt; &lt;cover-image class=&#x27;dew-img&#x27; src=&#x27;&#123;&#123;seller.pimg&#125;&#125;&#x27;&gt;&lt;/cover-image&gt; &lt;cover-view class=&quot;vedw&quot;&gt;商家简述: &#123;&#123;seller.des&#125;&#125;&lt;/cover-view&gt; &lt;cover-view class=&quot;po_w&quot;&gt; &lt;cover-view class=&quot;titd&quot;&gt;&#123;&#123;seller.name&#125;&#125;&lt;/cover-view&gt; &lt;cover-view class=&quot;addd&quot;&gt;&#123;&#123;seller.cityName&#125;&#125;&lt;/cover-view&gt; &lt;/cover-view&gt; &lt;/cover-view&gt; &lt;cover-view class=&quot;button cancel&quot; bindtap=&quot;modalhide&quot; &gt;退出&lt;/cover-view&gt; &lt;cover-view class=&quot;button confirm&quot; bindtap=&quot;modalshow&quot;&gt;进入商铺&lt;/cover-view&gt;&lt;/cover-view&gt;&lt;!-- &lt;/map/canvas&gt; --&gt; 1234567891011121314151617181920212223242526272829303132333435// .wxss.modal&#123; background-color: #fff; padding: 40rpx; box-sizing: border-box; width: 80%; height: auto; margin: 12% 10%; border-radius: 20rpx; border: 1rpx #ccc solid&#125;.dew-img&#123; width: 100%; height: 100%&#125;.vedw,.po_w&#123; line-height: 160%;&#125;.button&#123; display: block; margin: 20rpx 0 0; padding: 20rpx; font-size: 30rpx; width: 40%; color: #fff; text-align: center;&#125;.confirm&#123; float: left; background-color: rgb(112, 192, 117);&#125;.cancel&#123; float: right; background-color: rgb(186, 0, 0);&#125; 123456789101112131415161718// .jsPage(&#123; data: &#123; modalFlag: false &#125;, modalshow: function (e) &#123; this.setData(&#123; modalFlag: false &#125;) console.log(&quot;进入商铺&quot;) &#125;, modalhide: function (e) &#123; this.setData(&#123; modalFlag: true &#125;) console.log(&quot;关闭&quot;) &#125;&#125;) Modal 自定义 效果同内置 1234// .wxml&lt;modal hidden=&quot;&#123;&#123;hidden&#125;&#125;&quot; title=&quot;&#123;&#123;title&#125;&#125;&quot; confirm-text=&quot;自定义确定按钮&quot; cancel-text=&quot;自定义取消按钮&quot; bindcancel=&quot;cancel&quot; bindconfirm=&quot;confirm&quot; no-cancel=&quot;&#123;&#123;nocancel&#125;&#125;&quot;&gt; &#123;&#123;content&#125;&#125;&lt;/modal&gt; 1234567891011121314151617181920// .jsPage(&#123; data:&#123; hidden: false, nocancel: false, title: &quot;这里是title&quot;, content: &quot;这是对话框的内容。&quot; &#125;, cancel: function()&#123; this.setData(&#123; hidden: true &#125;); &#125;, confirm: function()&#123; this.setData(&#123; nocancel: !this.data.nocancel // 隐藏取消按钮 &#125;); console.log(&quot;clicked confirm&quot;); &#125;&#125;) 几种混合弹窗效果 ( 提示+模态框+上滑菜单 ) 12345678// .wxml&lt;span style=&quot;font-family:Comic Sans MS;font-size:18px;color:#333333;&quot;&gt; &lt;view class=&quot;container&quot; class=&quot;zn-uploadimg&quot;&gt; &lt;button type=&quot;primary&quot;bindtap=&quot;showok&quot;&gt;消息提示框&lt;/button&gt; &lt;button type=&quot;primary&quot;bindtap=&quot;modalcnt&quot;&gt;模态弹窗&lt;/button&gt; &lt;button type=&quot;primary&quot;bindtap=&quot;actioncnt&quot;&gt;操作菜单&lt;/button&gt; &lt;/view&gt;&lt;/span&gt; 123456789101112131415161718192021222324252627282930313233343536// .js//获取应用实例 var app = getApp()Page(&#123; showok: function () &#123; wx.showToast(&#123; title: &#x27;成功&#x27;, icon: &#x27;success&#x27;, duration: 2000 &#125;) &#125;, modalcnt: function () &#123; wx.showModal(&#123; title: &#x27;提示&#x27;, content: &#x27;这是一个模态弹窗&#x27;, success: function (res) &#123; if (res.confirm) &#123; console.log(&#x27;用户点击确定&#x27;) &#125; else if (res.cancel) &#123; console.log(&#x27;用户点击取消&#x27;) &#125; &#125; &#125;) &#125;, actioncnt: function () &#123; wx.showActionSheet(&#123; itemList: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;], success: function (res) &#123; console.log(res.tapIndex) &#125;, fail: function (res) &#123; console.log(res.errMsg) &#125; &#125;) &#125; &#125;) 模拟短信验证 ( modal+输入框 ) 1234567// .wxml&lt;view class=&quot;container&quot; class=&quot;zn-uploadimg&quot;&gt; &lt;button type=&quot;primary&quot;bindtap=&quot;modalinput&quot;&gt;modal有输入框&lt;/button&gt; &lt;/view&gt; &lt;modal hidden=&quot;&#123;&#123;hiddenmodalput&#125;&#125;&quot; title=&quot;请输入验证码&quot; confirm-text=&quot;提交&quot; cancel-text=&quot;重置&quot; bindcancel=&quot;cancel&quot; bindconfirm=&quot;confirm&quot;&gt; &lt;input type=&#x27;text&#x27;placeholder=&quot;请输入内容&quot; auto-focus/&gt; &lt;/modal&gt; 123456789101112131415161718192021222324252627// .jsvar app = getApp() Page(&#123; data:&#123; hiddenmodalput:true, //可以通过hidden是否掩藏弹出框的属性，来指定那个弹出框 &#125;, //点击按钮痰喘指定的hiddenmodalput弹出框 modalinput:function()&#123; this.setData(&#123; hiddenmodalput: !this.data.hiddenmodalput &#125;) &#125;, //取消按钮 cancel: function()&#123; this.setData(&#123; hiddenmodalput: true &#125;); &#125;, //确认 confirm: function()&#123; this.setData(&#123; hiddenmodalput: true &#125;) &#125; &#125;) 一般使用默认组件设置自定义样式，会带给用户更优质的操作体验，性能和美观度方面都是比较良好的~","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://merlinahh.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"author":"Merlin"},{"title":"小程序_TOAST 弹窗提示的几种设置方法","slug":"wxapp-toast-show","date":"2017-11-01T02:42:08.000Z","updated":"2024-02-28T00:44:59.027Z","comments":true,"path":"2017/11/01/wxapp-toast-show/","link":"","permalink":"https://merlinahh.github.io/2017/11/01/wxapp-toast-show/","excerpt":"","text":"小程序内置 Toast 组件123456789101112131415// 1 wx.showToast(&#123; title: &#x27;nihao&#x27;, // 定义弹窗提示文本 icon: &#x27;succes&#x27;, // 定义弹窗图标显示样式 // succes loading duration: 10000 // 提示延迟&#125;)// 2 wx.showToast(&#123; // 定义弹窗显示 title: &#x27;加载中&#x27;, icon: &#x27;loading&#x27;, duration: 10000 // 提示延迟&#125;) setTimeout(function()&#123; wx.hideToast() // 定义弹窗隐藏&#125;,2000) 自定义 toasttoast 自定义 定时器设置弹窗显示时间12345// .wxml&lt;!--点击button触发toast--&gt;&lt;button type=&quot;primary&quot; bindtap=&quot;listenerButton&quot;&gt;点击显示toast&lt;/button&gt;&lt;!--toast消息框显示3秒，并绑定事件--&gt;&lt;toast hidden=&quot;&#123;&#123;hiddenToast&#125;&#125;&quot; duration=&quot;3000&quot; bindchange=&quot;toastHidden&quot; &gt;OK!&lt;/toast&gt; 12345678910111213141516// .jsPage(&#123; data:&#123; // text:&quot;这是一个页面&quot; hiddenToast: true &#125;, listenerButton: function() &#123; // 监听button点击事件 this.setData(&#123; hiddenToast: !this.data.hiddenToast &#125;) &#125;, toastHidden:function()&#123; // toast显示时间到时处理业务 this.setData(&#123; hiddenToast: true &#125;) &#125;&#125;) toast 自定义 自设置结构定义图标显示代码 .wxml 部分 12345678910111213141516171819// .wxml&lt;!--按钮--&gt; &lt;view style=&quot;&#123;&#123;isShowToast?&#x27;position:fixed;&#x27;:&#x27;&#x27;&#125;&#125;&quot;&gt; &lt;view class=&quot;btn&quot; bindtap=&quot;clickBtn&quot;&gt;button&lt;/view&gt; &lt;/view&gt; &lt;!--mask--&gt; &lt;view class=&quot;toast_mask&quot; wx:if=&quot;&#123;&#123;isShowToast&#125;&#125;&quot;&gt;&lt;/view&gt; &lt;!--以下为toast显示的内容--&gt; &lt;view class=&quot;toast_content_box&quot; wx:if=&quot;&#123;&#123;isShowToast&#125;&#125;&quot;&gt; &lt;view class=&quot;toast_content&quot;&gt; &lt;view class=&quot;toast_content_text&quot;&gt; &lt;view class=&quot;toast_pic&quot; style=&quot;background:url(&#x27;&#123;&#123;toastimg&#125;&#125;&#x27;) no-repeat; background-size: contain; background-position: center&quot;&gt; &lt;!-- 这里实现 toast_pic 的背景图 --&gt; &lt;!-- &lt;image src=&#x27;&#123;&#123;toastimg&#125;&#125;&#x27;&gt;&lt;/image&gt; --&gt; &lt;/view&gt; &#123;&#123;toastText&#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; 代码 wxss 部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// .wxssPage &#123; background: #fff; &#125; /*按钮*/ .btn &#123; font-size: 28rpx; padding: 15rpx 30rpx; width: 100rpx; margin: 20rpx; text-align: center; border-radius: 10rpx; border: 1px solid #000; &#125; /*mask*/ .toast_mask &#123; opacity: 0; width: 100%; height: 100%; overflow: hidden; position: fixed; top: 0; left: 0; z-index: 888; &#125; /*toast*/ .toast_content_box &#123; display: flex; width: 100%; height: 100%; justify-content: center; align-items: center; position: fixed; z-index: 999; &#125; .toast_content &#123; width: 50%; padding: 20rpx; background: rgba(0, 0, 0, 0.5); border-radius: 20rpx; &#125; .toast_content_text &#123; height: 100%; width: 100%; color: #fff; font-size: 28rpx; text-align: center; &#125; .toast_pic&#123; // 设置 toast_pic width: 100%; height: 500rpx;&#125; 代码 js 部分 12345678910111213141516171819202122232425262728// .jsPage(&#123; data: &#123; //toast默认不显示 isShowToast: false &#125;, showToast: function () &#123; var _this = this; _this.data.count = parseInt(_this.data.count) ? parseInt(_this.data.count) : 3000; // toast时间 _this.setData(&#123; // 显示toast isShowToast: true, &#125;); setTimeout(function () &#123; // 定时器关闭 _this.setData(&#123; isShowToast: false &#125;); &#125;, _this.data.count); &#125;, clickBtn: function () &#123; // 点击按钮 console.log(&quot;你点击了按钮&quot;) //设置toast时间，toast内容 this.setData(&#123; count: 1500, toastText: &#x27;Michael’s Toast&#x27;, toastimg: &#x27;/assets/wechat.png&#x27; &#125;); this.showToast(); &#125; &#125;) 最终实现小程序弹窗提示。","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://merlinahh.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"author":"Merlin"},{"title":"PC端鼠标及键盘的禁用","slug":"Disable-the-mouse-and-keyboard-on-the-browser","date":"2017-08-07T23:32:15.000Z","updated":"2024-02-28T00:42:45.759Z","comments":true,"path":"2017/08/08/Disable-the-mouse-and-keyboard-on-the-browser/","link":"","permalink":"https://merlinahh.github.io/2017/08/08/Disable-the-mouse-and-keyboard-on-the-browser/","excerpt":"","text":"禁用右键🈲止鼠标右键点击，禁止选中文本123456789101112131415161718192021222324if (window.Event) document.captureEvents(Event.MOUSEUP); function nocontextmenu()&#123; event.cancelBubble = true event.returnValue = false; return false;&#125;function norightclick(e)&#123; if (window.Event) &#123; if (e.which == 2 || e.which == 3) return false; &#125; else if (event.button == 2 || event.button == 3)&#123; event.cancelBubble = true event.returnValue = false; return false; &#125;&#125;document.oncontextmenu = nocontextmenu; // for IE5+document.onmousedown = norightclick; // for all othersdocument.oncontextmenu = function()&#123; return false;&#125; 禁用f1212345678document.oncontextmenu = function () &#123; return false; &#125;;document.onkeydown = function () &#123; if (window.event &amp;&amp; window.event.keyCode == 123) &#123; event.keyCode = 0; event.returnValue = false; return false; &#125;&#125;; 1234567891011121314151617181920document.onkeydown = function()&#123; if(window.event &amp;&amp; window.event.keyCode == 123) &#123; event.keyCode=0; event.returnValue=false; &#125; if(window.event &amp;&amp; window.event.keyCode == 13) &#123; window.event.keyCode = 505; alert(进入); &#125; if(window.event &amp;&amp; window.event.keyCode == 8) &#123; alert(str+&quot;\\n请使用Del键进行字符的删除操作！&quot;); window.event.returnValue=false; alert(空格); &#125; if(window.event &amp;&amp; window.event.keyCode == 64)&#123; window.event.returnValue=false; alert(哈哈) &#125;&#125;; 禁止选中12345678910111213document.onselectstart = function (event)&#123; if(window.event)&#123; event = window.event; &#125;try&#123; var the = event.srcElement; if (!((the.tagName == &quot;INPUT&quot; &amp;&amp; the.type.toLowerCase() == &quot;text&quot;) || the.tagName == &quot;TEXTAREA&quot;))&#123; return false; &#125; return true; &#125; catch (e) &#123; return false; &#125;&#125;; 禁止复制12345678910111213document.oncontextmenu = function (event)&#123; if(window.event)&#123; event = window.event; &#125;try&#123; var the = event.srcElement; if (!((the.tagName == &quot;INPUT&quot; &amp;&amp; the.type.toLowerCase() == &quot;text&quot;) || the.tagName == &quot;TEXTAREA&quot;))&#123; return false; &#125; return true; &#125;catch (e)&#123; return false; &#125;&#125;; 禁止审查元素1234567891011121314151617181920212223jQuery(document).keydown(function(event) &#123; var src = (event.srcElement || event.target); if (src != null &amp;&amp; src.nodeType == 1) &#123; var nodeName = src.nodeName.toLowerCase(); if (nodeName == &quot;input&quot; || nodeName == &quot;textarea&quot;) &#123; return true; &#125; &#125; if (event.keyCode == 67 &amp;&amp; event.ctrlKey == true) &#123; return false; &#125; return true;&#125;);jQuery(document).keyup(function(event) &#123; var src = (event.srcElement || event.target); if (src != null &amp;&amp; src.nodeType == 1) &#123; var nodeName = src.nodeName.toLowerCase(); if (nodeName == &quot;input&quot; || nodeName == &quot;textarea&quot;) &#123; return true; &#125; &#125;&#125;) 禁用大全keycode 数字对应的按键 (键盘码) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147keycode 8 = BackSpace BackSpacekeycode 9 = Tab Tabkeycode 12 = Clearkeycode 13 = Enterkeycode 16 = Shift_Lkeycode 17 = Control_Lkeycode 18 = Alt_Lkeycode 19 = Pausekeycode 20 = Caps_Lockkeycode 27 = Escape Escapekeycode 32 = space spacekeycode 33 = Priorkeycode 34 = Nextkeycode 35 = Endkeycode 36 = Homekeycode 37 = Leftkeycode 38 = Upkeycode 39 = Rightkeycode 40 = Downkeycode 41 = Selectkeycode 42 = Printkeycode 43 = Executekeycode 45 = Insertkeycode 46 = Deletekeycode 47 = Helpkeycode 48 = 0 equal bracerightkeycode 49 = 1 exclam onesuperiorkeycode 50 = 2 quotedbl twosuperiorkeycode 51 = 3 section threesuperiorkeycode 52 = 4 dollarkeycode 53 = 5 percentkeycode 54 = 6 ampersandkeycode 55 = 7 slash braceleftkeycode 56 = 8 parenleft bracketleftkeycode 57 = 9 parenright bracketrightkeycode 65 = a Akeycode 66 = b Bkeycode 67 = c Ckeycode 68 = d Dkeycode 69 = e E EuroSignkeycode 70 = f Fkeycode 71 = g Gkeycode 72 = h Hkeycode 73 = i Ikeycode 74 = j Jkeycode 75 = k Kkeycode 76 = l Lkeycode 77 = m M mukeycode 78 = n Nkeycode 79 = o Okeycode 80 = p Pkeycode 81 = q Q atkeycode 82 = r Rkeycode 83 = s Skeycode 84 = t Tkeycode 85 = u Ukeycode 86 = v Vkeycode 87 = w Wkeycode 88 = x Xkeycode 89 = y Ykeycode 90 = z Zkeycode 96 = KP_0 KP_0keycode 97 = KP_1 KP_1keycode 98 = KP_2 KP_2keycode 99 = KP_3 KP_3keycode 100 = KP_4 KP_4keycode 101 = KP_5 KP_5keycode 102 = KP_6 KP_6keycode 103 = KP_7 KP_7keycode 104 = KP_8 KP_8keycode 105 = KP_9 KP_9keycode 106 = KP_Multiply KP_Multiplykeycode 107 = KP_Add KP_Addkeycode 108 = KP_Separator KP_Separatorkeycode 109 = KP_Subtract KP_Subtractkeycode 110 = KP_Decimal KP_Decimalkeycode 111 = KP_Divide KP_Dividekeycode 112 = F1keycode 113 = F2keycode 114 = F3keycode 115 = F4keycode 116 = F5keycode 117 = F6keycode 118 = F7keycode 119 = F8keycode 120 = F9keycode 121 = F10keycode 122 = F11keycode 123 = F12keycode 124 = F13keycode 125 = F14keycode 126 = F15keycode 127 = F16keycode 128 = F17keycode 129 = F18keycode 130 = F19keycode 131 = F20keycode 132 = F21keycode 133 = F22keycode 134 = F23keycode 135 = F24keycode 136 = Num_Lockkeycode 137 = Scroll_Lockkeycode 187 = acute gravekeycode 188 = comma semicolonkeycode 189 = minus underscorekeycode 190 = period colonkeycode 192 = numbersign apostrophekeycode 210 = plusminus hyphen macronkeycode 211 =keycode 212 = copyright registeredkeycode 213 = guillemotleft guillemotrightkeycode 214 = masculine ordfemininekeycode 215 = ae AEkeycode 216 = cent yenkeycode 217 = questiondown exclamdownkeycode 218 = onequarter onehalf threequarterskeycode 220 = less greater barkeycode 221 = plus asterisk asciitildekeycode 227 = multiply divisionkeycode 228 = acircumflex Acircumflexkeycode 229 = ecircumflex Ecircumflexkeycode 230 = icircumflex Icircumflexkeycode 231 = ocircumflex Ocircumflexkeycode 232 = ucircumflex Ucircumflexkeycode 233 = ntilde Ntildekeycode 234 = yacute Yacutekeycode 235 = oslash Oobliquekeycode 236 = aring Aringkeycode 237 = ccedilla Ccedillakeycode 238 = thorn THORNkeycode 239 = eth ETHkeycode 240 = diaeresis cedilla currencykeycode 241 = agrave Agrave atilde Atildekeycode 242 = egrave Egravekeycode 243 = igrave Igravekeycode 244 = ograve Ograve otilde Otildekeycode 245 = ugrave Ugravekeycode 246 = adiaeresis Adiaeresiskeycode 247 = ediaeresis Ediaeresiskeycode 248 = idiaeresis Idiaeresiskeycode 249 = odiaeresis Odiaeresiskeycode 250 = udiaeresis Udiaeresiskeycode 251 = ssharp question backslashkeycode 252 = asciicircum degreekeycode 253 = 3 sterlingkeycode 254 = Mode_switch","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://merlinahh.github.io/tags/js/"},{"name":"笔记","slug":"笔记","permalink":"https://merlinahh.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Merlin"},{"title":"关于浏览器显示的一些有趣操作~~~","slug":"Some-things-about-browser-display","date":"2017-04-30T22:55:27.000Z","updated":"2024-02-28T00:44:45.376Z","comments":true,"path":"2017/05/01/Some-things-about-browser-display/","link":"","permalink":"https://merlinahh.github.io/2017/05/01/Some-things-about-browser-display/","excerpt":"","text":"监听用户停留页面并改变标题显示12345678var normal_title = document.title;document.addEventListener(&#x27;visibilitychange&#x27;, function() &#123; if(document.visibilityState == &#x27;hidden&#x27;) &#123; // 用户离开页面 document.title = &#x27;肥来接着看鸭(づ￣ 3￣)づ~~~&#x27;; &#125; else &#123; document.title = normal_title; &#125;&#125;); 用户停留当前页时 用户离开当前页时 通过样式自定义浏览器右侧滚动条123456789::-webkit-scrollbar &#123; width: 30px; // 滚动条宽度&#125;::-webkit-scrollbar-thumb &#123; border-radius: 10px; // 滚动条圆角 background-color: rgba(0, 69, 109, 0.2); // 滚动条背景 ... // 可添加更多样式&#125; 浏览器滚动条默认样式 修改后的样式 也可调整至仅对某元素生效 12.bar::-webkit-scrollbar &#123;&#125;.bar::-webkit-scrollbar-thumb &#123;&#125; 通过 CSS 更改鼠标指针样式鼠标指针的不同样式鼠标的样式变化和cursor属性有关，默认值为 default 1cursor: default; 也可设置以下属性值 123456default：默认光标；pointer：超链接的指针；wait：表示程序正在忙；help：指示可用帮助；text：指示文本；crosshair：鼠标呈现十字状； 鼠标悬浮以下文字查看效果： 默认光标 超链接的指针小手 指程序正在忙沙漏 指示可用的帮助 指示文本 十字状 使用图片文件cursor 属性可以使用 url 赋值一个图片文件。 1cursor: url(图片地址), pointer;","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://merlinahh.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://merlinahh.github.io/tags/HTML-CSS/"}],"author":"Merlin"},{"title":"正则替换非法金额","slug":"validatorMoney","date":"2017-04-17T07:40:40.000Z","updated":"2024-02-28T00:39:57.535Z","comments":true,"path":"2017/04/17/validatorMoney/","link":"","permalink":"https://merlinahh.github.io/2017/04/17/validatorMoney/","excerpt":"","text":"用于需要校验输入框内填写内容的时候 val： 传入输入的字符串 12345678910function validatorMoney(val) &#123; let num = val .toString() .replace(/(^00)/, &quot;&quot;) .replace(/^[^\\d]*(\\d*\\.?\\d&#123;0,2&#125;)(.*)?$/, &quot;$1&quot;); if (num.length &gt; 1 &amp;&amp; num[0] === &quot;0&quot; &amp;&amp; !num.includes(&quot;.&quot;)) &#123; num = num.substring(1); &#125; return num;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://merlinahh.github.io/tags/js/"},{"name":"笔记","slug":"笔记","permalink":"https://merlinahh.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Merlin"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"服务器","slug":"服务器","permalink":"https://merlinahh.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"数据库","slug":"数据库","permalink":"https://merlinahh.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://merlinahh.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Node.js","slug":"Node-js","permalink":"https://merlinahh.github.io/tags/Node-js/"},{"name":"VUE","slug":"VUE","permalink":"https://merlinahh.github.io/tags/VUE/"},{"name":"前端","slug":"前端","permalink":"https://merlinahh.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"node","slug":"node","permalink":"https://merlinahh.github.io/tags/node/"},{"name":"js","slug":"js","permalink":"https://merlinahh.github.io/tags/js/"},{"name":"Linux","slug":"Linux","permalink":"https://merlinahh.github.io/tags/Linux/"},{"name":"shell脚本","slug":"shell脚本","permalink":"https://merlinahh.github.io/tags/shell%E8%84%9A%E6%9C%AC/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://merlinahh.github.io/tags/MongoDB/"},{"name":"yarn","slug":"yarn","permalink":"https://merlinahh.github.io/tags/yarn/"},{"name":"scp","slug":"scp","permalink":"https://merlinahh.github.io/tags/scp/"},{"name":"Nginx","slug":"Nginx","permalink":"https://merlinahh.github.io/tags/Nginx/"},{"name":"GitHub Page","slug":"GitHub-Page","permalink":"https://merlinahh.github.io/tags/GitHub-Page/"},{"name":"HEXO","slug":"HEXO","permalink":"https://merlinahh.github.io/tags/HEXO/"},{"name":"小程序","slug":"小程序","permalink":"https://merlinahh.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://merlinahh.github.io/tags/HTML-CSS/"},{"name":"RegExp","slug":"RegExp","permalink":"https://merlinahh.github.io/tags/RegExp/"}]}